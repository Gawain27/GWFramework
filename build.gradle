// ===================================================================
// ROOT build.gradle â€“ wiring + high-level tasks
// ===================================================================

apply from: "$rootDir/gradle/config.gradle"
apply from: "$rootDir/gradle/versioning.gradle"
apply from: "$rootDir/gradle/subprojects.gradle"
apply from: "$rootDir/gradle/testing.gradle"
apply from: "$rootDir/gradle/i18n.gradle"
apply from: "$rootDir/gradle/dependency-graph.gradle"
apply from: "$rootDir/gradle/distribution.gradle"
apply from: "$rootDir/gradle/misc.gradle"

// If someone runs `gradlew run` at the root, only execute the root :run task.
// Prevents :tools:translation-editor:run (and any other :run) from also firing.
gradle.taskGraph.whenReady {
  // Was a "run" selector used from the root?
  if (gradle.startParameter.taskNames.any { it == 'run' || it.endsWith(':run') }) {
    // Disable every run task except the root one
    allprojects {
      tasks.matching { it.name == 'run' && it.path != ':run' }.configureEach {
        enabled = false
      }
    }
  }
}

// ------------------------------------------------------------------
//  guarantee `includedProjects` exists
// ------------------------------------------------------------------
def includedProjects = (project.hasProperty('includedProjects')
  ? project.includedProjects
  : subprojects)

// ------------------------------------------------------------------
//  helper task provider lists (keep the _TaskProvider_ type intact!)
// ------------------------------------------------------------------
def buildTasks = includedProjects.collect { it.tasks.named('build') }
def classTasks = includedProjects.collect { it.tasks.named('classes') }
def testTasks  = includedProjects.collect { it.tasks.named('test') }
def cleanTasks = includedProjects.collect { it.tasks.named('clean') }

// ------------------------------------------------------------------
//  high-level umbrella tasks
// ------------------------------------------------------------------
tasks.register('build') {
  dependsOn buildTasks
  dependsOn tasks.named('assembleChangelog')
  dependsOn 'generateRunScripts', 'zipDistribution', 'tarDistribution'
}

tasks.register('run', Exec) {
  dependsOn classTasks, 'generateRunScripts'
  mustRunAfter 'zipDistribution', 'tarDistribution'

  doFirst {
    File binDir   = file("$buildDir/generatedConfig/${configSet}-${projectVersion}/bin")
    File launcher = org.gradle.internal.os.OperatingSystem.current().isWindows()
      ? new File(binDir, 'run.bat')
      : new File(binDir, 'run.sh')

    if (!launcher.exists()) {
      throw new GradleException("Launcher script not found: $launcher")
    }

    // IMPORTANT: run from the bin directory so relative classpath in the script works
    workingDir binDir

    // On *nix make sure itâ€™s executable
    if (!org.gradle.internal.os.OperatingSystem.current().isWindows()) {
      launcher.setExecutable(true)
    }

    // Build the command
    commandLine launcher.name.endsWith('.bat')
      ? ['cmd', '/c', launcher.absolutePath]
      : ['bash', launcher.absolutePath]
  }

  // Donâ€™t fail the task if the game exits with non-zero (window closed, etc.)
  ignoreExitValue = true

  // (Optional) stream child output into Gradleâ€™s console
  standardOutput = System.out
  errorOutput    = System.err

  doLast {
    def code = executionResult.get().exitValue
    if (code != 0) {
      logger.lifecycle("â„¹ï¸  Game process exited with code ${code}; treating as normal shutdown.")
    }
  }
}

tasks.register('delivery') {
  group       = 'distribution'
  description = 'Assemble distributable archives (zip & tar) and run tests.'
  dependsOn tasks.named('assembleChangelog')
  dependsOn testTasks, 'zipDistribution', 'tarDistribution'
}

tasks.register('clean', Delete) {
  dependsOn cleanTasks
  delete layout.buildDirectory
}

// ===================================================================
//  ðŸ”„  refreshAssets â€“ download & regenerate asset meta only
// ===================================================================
tasks.register('refreshAssets') {
  group       = 'build'
  description = 'Download remote resource ZIPs and regenerate assets.txt + enum classes.'

  // collect the 3 task providers from every participating sub-project
  def updates  = subprojects.collectMany { p ->
    p.tasks.matching { it.name == 'updateResources' }
  }
  def txts     = subprojects.collectMany { p ->
    p.tasks.matching { it.name == 'generateAssetsTxt' }
  }
  def enums    = subprojects.collectMany { p ->
    p.tasks.matching { it.name == 'generateAssetEnums' }
  }

  dependsOn updates
  dependsOn txts
  dependsOn enums
}


println 'âœ…  root build.gradle loaded â€“ high-level tasks configured'
