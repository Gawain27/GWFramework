// ===================================================================
// ROOT build.gradle â€“ wiring + high-level tasks
// ===================================================================

apply from: "$rootDir/gradle/config.gradle"
apply from: "$rootDir/gradle/versioning.gradle"
apply from: "$rootDir/gradle/subprojects.gradle"
apply from: "$rootDir/gradle/testing.gradle"
apply from: "$rootDir/gradle/i18n.gradle"
apply from: "$rootDir/gradle/dependency-graph.gradle"
apply from: "$rootDir/gradle/distribution.gradle"
apply from: "$rootDir/gradle/misc.gradle"

// If someone runs `gradlew run` at the root, only execute the root :run task.
// Prevents :tools:translation-editor:run (and any other :run) from also firing.
gradle.taskGraph.whenReady {
  // Was a "run" selector used from the root?
  if (gradle.startParameter.taskNames.any { it == 'run' || it.endsWith(':run') }) {
    // Disable every run task except the root one
    allprojects {
      tasks.matching { it.name == 'run' && it.path != ':run' }.configureEach {
        enabled = false
      }
    }
  }
}

// ------------------------------------------------------------------
//  guarantee `includedProjects` exists
// ------------------------------------------------------------------
def includedProjects = (project.hasProperty('includedProjects')
  ? project.includedProjects
  : subprojects)

// ------------------------------------------------------------------
//  helper task provider lists (keep the _TaskProvider_ type intact!)
// ------------------------------------------------------------------
def buildTasks = includedProjects.collect { it.tasks.named('build') }
def classTasks = includedProjects.collect { it.tasks.named('classes') }
def testTasks  = includedProjects.collect { it.tasks.named('test') }
def cleanTasks = includedProjects.collect { it.tasks.named('clean') }

// ------------------------------------------------------------------
//  high-level umbrella tasks
// ------------------------------------------------------------------
tasks.register('build') {
  group = 'build'
  description = 'Build all included projects (no tests, no distribution archives).'
  dependsOn buildTasks
  dependsOn tasks.named('assembleChangelog')
  dependsOn 'generateRunScripts'
}

tasks.register('testAll') {
  group = 'verification'
  description = 'Run tests for all included projects.'
  dependsOn testTasks
}

tasks.register('run', Exec) {
  dependsOn classTasks, 'generateRunScripts'
  //mustRunAfter 'zipDistribution', 'tarDistribution'

  doFirst {
    File binDir   = file("$buildDir/generatedConfig/${configSet}-${projectVersion}/bin")
    File launcher = org.gradle.internal.os.OperatingSystem.current().isWindows()
      ? new File(binDir, 'run.bat')
      : new File(binDir, 'run.sh')

    if (!launcher.exists()) {
      throw new GradleException("Launcher script not found: $launcher")
    }

    // IMPORTANT: run from the bin directory so relative classpath in the script works
    workingDir binDir

    // On *nix make sure itâ€™s executable
    if (!org.gradle.internal.os.OperatingSystem.current().isWindows()) {
      launcher.setExecutable(true)
    }

    // Build the command
    commandLine launcher.name.endsWith('.bat')
      ? ['cmd', '/c', launcher.absolutePath]
      : ['bash', launcher.absolutePath]
  }

  // Donâ€™t fail the task if the game exits with non-zero (window closed, etc.)
  ignoreExitValue = true

  // (Optional) stream child output into Gradleâ€™s console
  standardOutput = System.out
  errorOutput    = System.err

  doLast {
    def code = executionResult.get().exitValue
    if (code != 0) {
      logger.lifecycle("â„¹ï¸  Game process exited with code ${code}; treating as normal shutdown.")
    }
  }
}

tasks.register('delivery') {
  group       = 'distribution'
  description = 'Run tests and assemble distributable archives (zip & tar).'
  dependsOn tasks.named('assembleChangelog')
  dependsOn tasks.named('testAll')
  dependsOn 'generateRunScripts', 'zipDistribution', 'tarDistribution'
}

tasks.register('clean', Delete) {
  dependsOn cleanTasks
  delete layout.buildDirectory
}

// ===================================================================
//  ðŸ” resetAssetHashes â€“ set every *_hash in gradle.properties to 0
// ===================================================================
tasks.register('resetAssetHashes') {
  group = 'build'
  description = 'Set all *_hash properties in gradle.properties to 0.'

  // Adjust if your properties file lives elsewhere
  def propsFile = rootProject.file('gradle.properties')

  inputs.file(propsFile)
  outputs.file(propsFile)

  doLast {
    if (!propsFile.exists()) {
      throw new GradleException("gradle.properties not found at: ${propsFile}")
    }

    def original = propsFile.getText('UTF-8')
    def updated = original
    // Replace lines like: something_hash=12345   (preserve key, keep comments on same line)
      .replaceAll(/(?m)^(\s*[A-Za-z0-9_.-]+_hash)\s*=\s*([^\r\n#]*)(\s*(#.*)?)$/) { all, key, val, tail ->
        "${key}=0${tail ?: ''}"
      }

    if (updated != original) {
      propsFile.setText(updated, 'UTF-8')
      logger.lifecycle("âœ… Set *_hash properties to 0 in ${propsFile}")
    } else {
      logger.lifecycle("â„¹ï¸ No *_hash properties found to update in ${propsFile}")
    }
  }
}

// ===================================================================
//  ðŸ”„  refreshAssets â€“ download & regenerate asset meta only
// ===================================================================
tasks.named('refreshAssets').configure {
  // collect the tasks (TaskCollection is fine as dependsOn input)
  def updates = subprojects.collectMany { p -> p.tasks.matching { it.name == 'updateResources' } }
  def txts    = subprojects.collectMany { p -> p.tasks.matching { it.name == 'generateAssetsTxt' } }
  def enums   = subprojects.collectMany { p -> p.tasks.matching { it.name == 'generateAssetEnums' } }

  // First zero the hashes, then run updateResources, then regenerate metadata
  dependsOn tasks.named('resetAssetHashes')
  dependsOn updates
  dependsOn txts
  dependsOn enums

  // Enforce ordering: resetAssetHashes -> updateResources -> generators
  updates.each { it.mustRunAfter(tasks.named('resetAssetHashes')) }
  txts.each    { it.mustRunAfter(updates) }
  enums.each   { it.mustRunAfter(txts) }
}


println 'âœ…  root build.gradle loaded â€“ high-level tasks configured'
