// ===================================================================
// ROOT build.gradle â€“ wiring + high-level tasks
// ===================================================================

apply from: "$rootDir/gradle/config.gradle"
apply from: "$rootDir/gradle/versioning.gradle"
apply from: "$rootDir/gradle/subprojects.gradle"
apply from: "$rootDir/gradle/testing.gradle"
apply from: "$rootDir/gradle/i18n.gradle"
apply from: "$rootDir/gradle/dependency-graph.gradle"
apply from: "$rootDir/gradle/distribution.gradle"
apply from: "$rootDir/gradle/misc.gradle"

// If someone runs `gradlew run` at the root, only execute the root :run task.
// Prevents :tools:translation-editor:run (and any other :run) from also firing.
gradle.taskGraph.whenReady {
  if (gradle.startParameter.taskNames.any { it == 'run' || it.endsWith(':run') }) {
    allprojects {
      tasks.matching { it.name == 'run' && it.path != ':run' }.configureEach {
        enabled = false
      }
    }
  }
}

// ------------------------------------------------------------------
//  guarantee `includedProjects` exists
// ------------------------------------------------------------------
def includedProjects = (project.hasProperty('includedProjects')
  ? project.includedProjects
  : subprojects)

// ------------------------------------------------------------------
//  helper task provider lists (keep the _TaskProvider_ type intact!)
// ------------------------------------------------------------------
def buildTasks = includedProjects.collect { it.tasks.named('build') }
def classTasks = includedProjects.collect { it.tasks.named('classes') }
def testTasks  = includedProjects.collect { it.tasks.named('test') }
def cleanTasks = includedProjects.collect { it.tasks.named('clean') }

// ------------------------------------------------------------------
//  high-level umbrella tasks
// ------------------------------------------------------------------
tasks.register('build') {
  group = 'build'
  description = 'Build all included projects (no tests, no distribution archives).'
  dependsOn buildTasks
  dependsOn tasks.named('assembleChangelog')
  dependsOn 'generateRunScripts'
}

tasks.register('testAll') {
  group = 'verification'
  description = 'Run tests for all included projects.'
  dependsOn testTasks
}

tasks.register('run', Exec) {
  dependsOn classTasks, 'generateRunScripts'

  doFirst {
    // By depending on generateRunScripts we expect the bin dir to exist now.
    File binDir = file("$buildDir/generatedConfig/${configSet}-${projectVersion}/bin")
    if (!binDir.exists()) {
      throw new GradleException(
        "Expected runtime folder not found: ${binDir}\n" +
          "Something prevented the distribution scripts from being generated. " +
          "Try running ':generateRunScripts' (or ':build') with --info."
      )
    }

    File launcher = org.gradle.internal.os.OperatingSystem.current().isWindows()
      ? new File(binDir, 'run.bat')
      : new File(binDir, 'run.sh')

    if (!launcher.exists()) {
      throw new GradleException("Launcher script not found: $launcher")
    }

    // IMPORTANT: run from the bin directory so relative classpath in the script works
    workingDir binDir

    // On *nix make sure itâ€™s executable
    if (!org.gradle.internal.os.OperatingSystem.current().isWindows()) {
      launcher.setExecutable(true)
    }

    // Build the command
    commandLine launcher.name.endsWith('.bat')
      ? ['cmd', '/c', launcher.absolutePath]
      : ['bash', launcher.absolutePath]
  }

  // Donâ€™t fail the task if the game exits with non-zero (window closed, etc.)
  ignoreExitValue = true

  // stream child output into Gradleâ€™s console
  standardOutput = System.out
  errorOutput    = System.err

  doLast {
    def code = executionResult.get().exitValue
    if (code != 0) {
      logger.lifecycle("â„¹ï¸  Game process exited with code ${code}; treating as normal shutdown.")
    }
  }
}

tasks.register('delivery') {
  group       = 'distribution'
  description = 'Run tests and assemble distributable archives (zip & tar).'
  dependsOn tasks.named('assembleChangelog')
  dependsOn tasks.named('testAll')
  dependsOn 'generateRunScripts', 'zipDistribution', 'tarDistribution'
}

tasks.register('clean', Delete) {
  dependsOn cleanTasks
  delete layout.buildDirectory
}

// ===================================================================
//  ðŸ” resetAssetHashes â€“ set every *_hash in gradle.properties to 0
// ===================================================================
tasks.register('resetAssetHashes') {
  group = 'build'
  description = 'Set all *_hash properties in each included subproject gradle.properties to 0.'

  doLast {
    includedProjects.each { p ->
      File propsFile = p.file('gradle.properties')
      if (!propsFile.exists()) return

      def original = propsFile.getText('UTF-8')
      def updated = original.replaceAll(/(?m)^(\s*[A-Za-z0-9_.-]+_hash)\s*=\s*([^\r\n#]*)(\s*(#.*)?)$/) { all, key, val, tail ->
        "${key}=0${tail ?: ''}"
      }

      if (updated != original) {
        propsFile.setText(updated, 'UTF-8')
        logger.lifecycle("âœ… Set *_hash to 0 in ${p.path}/${propsFile.name}")
      }
    }
  }
}

// ===================================================================
//  ðŸ”„ refreshAssets â€“ download & regenerate asset meta only
// ===================================================================
tasks.register('refreshAssets') {
  group       = 'build'
  description = 'Download remote resource ZIPs and regenerate assets.txt + enum classes.'

  dependsOn tasks.named('resetAssetHashes')

  // Just run the top-of-pipeline task per subproject
  def enumTasks = includedProjects.collectMany { p ->
    p.tasks.matching { it.name == 'generateAssetEnums' }
  }
  dependsOn enumTasks

  // Ordering: hashes must be reset before any module updates
  enumTasks.each { it.mustRunAfter(tasks.named('resetAssetHashes')) }
}

tasks.withType(JavaCompile).configureEach {
  options.compilerArgs += ['-Agw.init.strict=true']
}
println 'âœ…  root build.gradle loaded â€“ high-level tasks configured'
