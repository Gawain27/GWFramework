import groovy.json.JsonOutput
import groovy.json.JsonSlurper

println "üîµ [ROOT] Starting root build.gradle ------------------------------------------------"

/* =====================================================================
 * 0.  READ configSet
 * =================================================================== */
String configSet = project.findProperty('configSet')
if (!configSet) {
  def ini = file('config.ini')
  if (ini.exists()) {
    def p = new Properties(); ini.withReader { p.load(it) }
    configSet = p.getProperty('config_set')
  }
}
if (!configSet) throw new GradleException("‚ùå Pass -PconfigSet=<game> or define config.ini")

println "‚ÑπÔ∏è  projectVersion (root) = ${projectVersion}"

println "üîç Loading config file  configs/${configSet}.json"
def cfgFile = file("configs/${configSet}.json")
if (!cfgFile.exists()) throw new GradleException("‚ùå No such file $cfgFile")
def parsedConfig = new JsonSlurper().parse(cfgFile)

/* collect Gradle Project handles ----------------------------------- */
def includedProjects = parsedConfig.projects.collect { project(":$it.name") }
includedProjects.add project(":gwstarter")
def includedProjectNames = includedProjects*.name as Set
println "‚úÖ configSet=$configSet ‚Äì Included projects: $includedProjectNames"

/* =====================================================================
 * 1.  GLOBAL EXT & REPOS
 * =================================================================== */
ext.configSet = configSet
ext.translationKeysGlobal = [:]        // key -> module:enum for dup-check

def supportedLocales = (rootProject.findProperty('supportedLocales') ?: 'en_US')
  .split(',')*.trim()
println "üåê Supported locales: $supportedLocales"
subprojects { ext.configSet = rootProject.configSet }

buildscript {
  repositories {
    mavenCentral(); gradlePluginPortal(); mavenLocal(); google()
    maven { url 'https://oss.sonatype.org/content/repositories/snapshots/' }
    maven { url 'https://s01.oss.sonatype.org/content/repositories/snapshots/' }
  }
  dependencies {
    classpath "org.ow2.asm:asm:9.7"
  }
}

import org.objectweb.asm.ClassReader
import org.objectweb.asm.ClassVisitor
import org.objectweb.asm.Opcodes
import org.objectweb.asm.AnnotationVisitor

allprojects {
  apply plugin: 'idea'; apply plugin: 'eclipse'
  repositories {
    mavenCentral(); mavenLocal()
    maven { url 'https://oss.sonatype.org/content/repositories/snapshots/' }
    maven { url 'https://s01.oss.sonatype.org/content/repositories/snapshots/' }
    maven { url 'https://jitpack.io' }
  }
}

/* =====================================================================
 * 2.  BUMP buildVersion *before* jar tasks
 * =================================================================== */

// ‚òÖ A helper flag to know if the current invocation is a shipping build
boolean isShippingBuild = gradle.startParameter.taskNames.any {
  it.equalsIgnoreCase('build') || it.equalsIgnoreCase('delivery')
}

def projectBuildVersions = [:]

tasks.register('bumpBuildVersions') {
  doLast {
    println "üîº bumpBuildVersions ------------------------------------------------"
    includedProjects.each { prj ->
      def propsFile = prj.file('gradle.properties')
      def props = new Properties(); propsFile.withInputStream { props.load(it) }

      def buildVer = props.getProperty('buildVersion')?.toInteger() ?: 0
      def srcDir   = prj.file('src')
      def latest   = srcDir.exists() ? prj.fileTree(srcDir).files.max { it.lastModified() }?.lastModified() : 0L

      def stampF   = prj.file('.lastVersionCheck')
      def previous = stampF.exists() ? stampF.text.toLong() : 0L

      if (latest > previous) {
        buildVer++
        props.setProperty('buildVersion', buildVer.toString())
        propsFile.withOutputStream { props.store(it, null) }
        stampF.text = latest.toString()
        println "   ‚Ä¢ ${prj.name} ‚Üí buildVersion = $buildVer"
      }
      projectBuildVersions[prj.name] = buildVer
    }
  }
}

/* ---------- Helper: return buildVersion even when bump task not run - */
ext.buildVerOf = { String prjName ->
  projectBuildVersions[prjName] ?: new Properties().with {
    file("${project(":$prjName").projectDir}/gradle.properties")
      .withInputStream { load(it) }
    getProperty('buildVersion')
  }
}

/* =====================================================================
 * 3.  SUBPROJECT CONFIG
 * =================================================================== */

def projectLevels = [:]

/* Helper that inspects the class *without* loading it */
boolean isTranslationsEnum(File classFile) {
  def cr = new ClassReader(classFile.bytes)
  def isEnum = (cr.access & Opcodes.ACC_ENUM) != 0
  if (!isEnum) return false
  def found = false
  cr.accept(new ClassVisitor(Opcodes.ASM9) {
    @Override
    AnnotationVisitor visitAnnotation(String desc, boolean v) {
      if (desc == 'Lcom/gwngames/core/api/build/Translations;')
        found = true
      return null
    }
  }, ClassReader.SKIP_CODE | ClassReader.SKIP_DEBUG | ClassReader.SKIP_FRAMES)
  return found
}

subprojects { subproj ->
  if (!includedProjectNames.contains(subproj.name)) return

  apply plugin: 'java-library'
  sourceCompatibility = 21; targetCompatibility = 21
  version = projectVersion

  /* --------------------------------------------------------------
   * Jar naming & asset-list
   * ----------------------------------------------------------- */
  tasks.named('jar') {
    // bump version numbers only for shipping builds
    if (isShippingBuild) {
      dependsOn rootProject.tasks.named('bumpBuildVersions')
      outputs.upToDateWhen { false }          // force rebuild
    }
    doFirst {
      def props = new Properties()
      file("${projectDir}/gradle.properties").withInputStream { props.load(it) }
      archiveFileName.set("${subproj.name}-${props.getProperty('buildVersion')}.jar")
    }
  }

  tasks.register('generateAssetList') {
    doFirst  { println "üìù  ${subproj.name}: generating asset list ..." }
    doLast   { println "‚úÖ  ${subproj.name}: asset list done." }
    doLast {
      def resDir = file("$projectDir/resources")
      if (!resDir.exists()) return
      def out = new File(resDir, 'assets.txt'); if (out.exists()) out.delete()
      fileTree(resDir).matching { exclude 'assets.txt' }.collect { resDir.relativePath(it) }
        .sort()
        .each { rp -> if (!file("$resDir/$rp").directory) out << "$rp\n" }
    }
  }
  tasks.named('processResources') { dependsOn 'generateAssetList' }

  /* --------------------------------------------------------------
   *  Test support ‚Äì run any class extending BaseTest
   * ----------------------------------------------------------- */
  dependencies { testImplementation "org.junit.jupiter:junit-jupiter:5.10.2" }

  tasks.named('test', Test) {
    dependsOn rootProject.tasks.named('assembleTestRuntime')
    def binDir = rootProject.layout.buildDirectory
      .dir("generatedConfig/${configSet}-${projectVersion}/bin")
      .get().asFile
    systemProperty 'gw.bin.dir', binDir.absolutePath
    workingDir binDir
    useJUnitPlatform()
    testLogging { events "passed", "skipped", "failed" }
  }

  afterEvaluate {
    projectLevels[subproj.name] = findProperty('projectLevel')?.toInteger() ?: 0
  }

  /* --------------------------------------------------------------------
 *  I18N ‚Äì harvest enums annotated with @Translations and
 *         (re)generate messages.csv per module
 * ------------------------------------------------------------------ */
  subproj.tasks.register('updateTranslationsCsv') {
    group = 'i18n'
    description = 'Scan enums annotated with @Translations and update messages.csv'

    dependsOn subproj.tasks.named('compileJava')   // only needs byte-code
    mustRunAfter subproj.tasks.named('compileJava')

    doLast {
      println "üîç  ${subproj.path}: scanning for @Translations..."

      /* -----------------------------------------------------------
       * 1) Collect the class-files we *will* need to load
       * --------------------------------------------------------- */
      def toLoad = []
      def outputDirs = subproj.sourceSets.main.output.classesDirs
      outputDirs.files.each { dir ->
        if (!dir.exists()) return
        dir.eachFileRecurse { f ->
          if (f.name.endsWith('.class') && isTranslationsEnum(f))
            toLoad << [root: dir, file: f]
        }
      }

      if (toLoad.empty) {
        println "‚ÑπÔ∏è   no @Translations enums found - nothing to do."
        return
      }

      /* -----------------------------------------------------------
       * 2) Load *only those* enums with a minimal class-loader
       * --------------------------------------------------------- */
      def loader = new URLClassLoader(
        outputDirs.files.collect { it.toURI().toURL() } as URL[],
        (ClassLoader) null)          // still nothing from LibGDX, etc.

      def moduleKeys = [:]

      toLoad.each { map ->
        def rel = map.file.path - map.root.path - File.separator
        def className = rel.replace(File.separatorChar as char, '.' as char)
          .replaceAll(/\.class$/, '')
        Class<?> cls = loader.loadClass(className)

        cls.enumConstants.each { constant ->
          def key     = constant.getKey()
          def caption = constant.getDefaultCaption()
          /* -------- global duplicate check -------------- */
          def where = "${subproj.path}:${cls.simpleName}"
          def prev = rootProject.translationKeysGlobal.putIfAbsent(key, where)
          if (prev) throw new GradleException(
            "Duplicate translation key '$key': declared in $where, already in $prev")
          moduleKeys[key] = caption
        }
      }

      /* -----------------------------------------------------------
       * 3) Merge into messages.csv  (unchanged from before)
       * --------------------------------------------------------- */
      def csvFile = subproj.file('resources/translation/messages.csv')
      csvFile.parentFile.mkdirs()

      def header = (['key'] + supportedLocales) as List
      def rows   = [:]

      if (csvFile.exists()) {
        csvFile.readLines('UTF-8').withIndex { line, idx ->
          def cols = line.split(',', -1) as List
          if (idx == 0)      header = (['key'] + (cols - 'key' + supportedLocales)).unique()
          else               rows[cols[0]] = (cols + [''] * header.size()).take(header.size())
        }
      }

      moduleKeys.each { k, caption ->
        if (!rows.containsKey(k)) {
          def blank = [''] * header.size(); blank[0] = k
          def defCol = header.indexOf(supportedLocales[0])
          if (defCol >= 0) blank[defCol] = caption
          rows[k] = blank
        }
      }

      csvFile.withWriter('UTF-8') { w ->
        w.println header.join(',')
        rows.keySet().sort().each { k -> w.println rows[k].join(',') }
      }
      println "‚úÖ  ${csvFile} updated with ${moduleKeys.size()} keys"
    }
  }

  /* ensure it runs before resources are packed ------------------------ */
  subproj.tasks.named('processResources') { dependsOn 'updateTranslationsCsv' }
}

/* optional convenience umbrella task (root) --------------------------- */
tasks.register('updateAllTranslations') {
  group = 'i18n'
  description = 'Update messages.csv in every module'
  dependsOn subprojects.collect { it.tasks.matching { it.name == 'updateTranslationsCsv' } }
}

/* =====================================================================
 * 4.  DEP GRAPH
 * =================================================================== */

gradle.projectsEvaluated {
  subprojects { sp ->
    if (!includedProjectNames.contains(sp.name)) return
    def lvl = projectLevels[sp.name] ?: 0
    includedProjectNames.each { other ->
      if (other == sp.name) return
      if (lvl >= (projectLevels[other] ?: 0)) {
        sp.dependencies { implementation project(":$other") }
      }
    }
  }
}

/* =====================================================================
 * 5.  VERSION-JSON & unpack starter ZIP
 * =================================================================== */

tasks.register('injectProjectVersionIntoConfig') {
  dependsOn includedProjects.collect { it.tasks.named('jar') }

  doLast {
    def genDir = file("$buildDir/generatedConfig/${configSet}-${projectVersion}/bin")
    genDir.mkdirs()
    def jsonFile = new File(genDir, 'config.json')

    /* ---- project list ------------------------------------------------ */
    def projectsJson = parsedConfig.projects.collect { p ->
      [
        name : p.name,
        level: projectLevels[p.name],
        jar  : "lib/${p.name}-${buildVerOf(p.name)}.jar",    // ‚òÖ helper in use
        type : parsedConfig.gameType
      ]
    }

    /* add gwstarter entry --------------------------------------------- */
    projectsJson << ([
      name : 'gwstarter',
      level: projectLevels['gwstarter'] ?: 99,
      jar  : "lib/${configSet}-${projectVersion}-${buildVerOf('gwstarter')}.jar",
      type : parsedConfig.gameType
    ] as LinkedHashMap<String, GString>)

    def json = [ gameType: parsedConfig.gameType, projects: projectsJson ]
    jsonFile.text = JsonOutput.prettyPrint(JsonOutput.toJson(json))
    println "üìÑ  config.json written ‚Üí $jsonFile"
  }
}

/* ------------------------------------------------------------------ */
def starterBuildVersion = project.provider { buildVerOf('gwstarter') }
/* ------------------------------------------------------------------ */

tasks.register('prepareDistribution', Copy) {
  dependsOn project(':gwstarter').tasks.named('distZip')
  dependsOn tasks.named('injectProjectVersionIntoConfig')

  from zipTree(project(':gwstarter').layout.buildDirectory.file("distributions/gwstarter-${projectVersion}.zip"))
  eachFile {
    def rootOld = "gwstarter-${projectVersion}"
    def rootNew = "${configSet}-${projectVersion}"
    if (path.startsWith(rootOld)) path = path.replaceFirst(rootOld, rootNew)
    if (path ==~ /.*\/lib\/gwstarter-\d+\.jar$/) {
      path = path.replaceFirst(/gwstarter-\d+\.jar/,
        "${configSet}-${projectVersion}-${starterBuildVersion.get()}.jar")
    }
  }
  includeEmptyDirs = false
  into "$buildDir/generatedConfig"
}

/* =====================================================================
 * 5c.  COPY ALL MODULE JARS INTO lib/
 * =================================================================== */

tasks.register('copyProjectJarsToDistribution', Copy) {
  dependsOn tasks.named('prepareDistribution')
  dependsOn includedProjects.collect { it.tasks.named('jar') }

  doFirst { println "üì•  Copying freshly-built jars into distribution ‚Ä¶" }

  includedProjects.findAll { it.name != 'gwstarter' }.each { prj ->
    from prj.tasks.named('jar')
  }
  into "$buildDir/generatedConfig/${configSet}-${projectVersion}/lib"
  duplicatesStrategy = DuplicatesStrategy.EXCLUDE
}

/* =====================================================================
 * 5d.  PATHING-JAR & launch scripts
 * =================================================================== */

project(':gwstarter').tasks.matching { it.name == 'run' }.configureEach { enabled = false }

tasks.register('createPathingJar') {
  dependsOn tasks.named('copyProjectJarsToDistribution')

  doLast {
    def distroDir = file("$buildDir/generatedConfig/${configSet}-${projectVersion}")
    def binDir = new File(distroDir, 'bin'); binDir.mkdirs()
    def libDir = new File(distroDir, 'lib')
    def launcher = new File(binDir, 'launcher.jar')

    def libs = libDir.listFiles().findAll { it.name.endsWith('.jar') }
      .collect { "../lib/${it.name}" }
      .sort()
      .join(' ')

    ant.jar(destfile: launcher) {
      manifest {
        attribute(name: 'Manifest-Version', value: '1.0')
        attribute(name: 'Main-Class', value: 'com.gwngames.starter.Starter')
        attribute(name: 'Class-Path', value: libs)
      }
    }
    println "üì¶  Pathing JAR created ‚Üí $launcher"
  }
}

tasks.register('generateRunScripts') {
  dependsOn tasks.named('createPathingJar')

  doLast {
    def binDir = file("$buildDir/generatedConfig/${configSet}-${projectVersion}/bin")
    new File(binDir, 'run.sh').text = """#!/usr/bin/env bash
DIR="\$( cd "\${BASH_SOURCE%/*}" && pwd )"
"\${JAVA_HOME:+\$JAVA_HOME/bin/}java" -jar "\$DIR/launcher.jar" "\$@"
"""
    new File(binDir, 'run.sh').setExecutable(true)
    new File(binDir, 'run.bat').text = """@echo off
set DIRNAME=%~dp0
set JAVA=%JAVA_HOME%\\bin\\java.exe
if not exist "%JAVA%" set JAVA=java.exe
"%JAVA%" -jar "%DIRNAME%launcher.jar" %*
"""
    println "üöÄ  run.sh & run.bat written to $binDir"
  }
}

/* ---------------- one-time assembly used by every test task ---------- */
tasks.register('assembleTestRuntime') {
  dependsOn tasks.named('generateRunScripts')
  outputs.dir("$buildDir/generatedConfig/${configSet}-${projectVersion}/bin")
}

/* =====================================================================
 * 6.  DISTRO ARCHIVES
 * =================================================================== */

tasks.register('zipDistribution', Zip) {
  dependsOn tasks.named('generateRunScripts')
  archiveBaseName.set(configSet)
  archiveVersion.set("${projectVersion}-${starterBuildVersion.get()}")
  destinationDirectory.set(layout.buildDirectory.dir("distributions"))
  from layout.buildDirectory.dir("generatedConfig")
}

tasks.register('tarDistribution', Tar) {
  dependsOn tasks.named('generateRunScripts')
  archiveBaseName.set(configSet)
  archiveVersion.set("${projectVersion}-${starterBuildVersion.get()}")
  compression = Compression.GZIP
  destinationDirectory.set(layout.buildDirectory.dir("distributions"))
  from layout.buildDirectory.dir("generatedConfig")
}

/* =====================================================================
 * 7.  ROOT build / run / clean
 * =================================================================== */

// BUILD ‚Äì full CI pipeline --------------------------------------------
tasks.register('build') {
  dependsOn includedProjects.collect { it.tasks.named('build') }
  dependsOn tasks.named('generateRunScripts'),
    tasks.named('zipDistribution'),
    tasks.named('tarDistribution')
}

// RUN ‚Äì fast local launch ---------------------------------------------
tasks.register('run') {
  dependsOn includedProjects.collect { it.tasks.named('classes') }
  dependsOn tasks.named('generateRunScripts')
  mustRunAfter tasks.named('zipDistribution')
  mustRunAfter tasks.named('tarDistribution')

  doLast {
    def binDir = file("$buildDir/generatedConfig/${configSet}-${projectVersion}/bin")
    def launcher = org.gradle.internal.os.OperatingSystem.current().isWindows() ?
      new File(binDir, 'run.bat') : new File(binDir, 'run.sh')
    println "‚ñ∂Ô∏è  Launching via $launcher"
    exec {
      if (launcher.name.endsWith('.bat')) commandLine 'cmd', '/c', launcher
      else commandLine 'bash', launcher
    }
  }
}

// DELIVERY ‚Äì artefacts + tests ----------------------------------------
tasks.register('delivery') {
  group = 'distribution'
  description = 'Assemble distributable archives (zip & tar) and run tests.'
  dependsOn includedProjects.collect { it.tasks.named('test') }
  dependsOn tasks.named('zipDistribution'),
    tasks.named('tarDistribution')
}

tasks.register('clean', Delete) {
  delete layout.buildDirectory
  dependsOn includedProjects.collect { it.tasks.named('clean') }
}

/* =====================================================================
 * 8.  MISC
 * =================================================================== */

eclipse.project.name = 'GWFramework'
println "üîö root build.gradle configured -----------------------------------------------------"
