/* =========================================================================
 * Level-based implementation() wiring between included modules
 * ========================================================================= */
static String normName(Object o) {
  return o == null ? null : o.toString().trim().toLowerCase(Locale.ROOT)
}

Map<String, Integer> projectLevels = [:]
ext.projectLevels = projectLevels   // shared with other scripts

// Cache normalized included names once
Set<String> included = (includedProjectNames ?: [])
  .collect { normName(it) }
  .findAll { it }
  .toSet()

/* wire after all projects are evaluated */
gradle.projectsEvaluated {
  // 1) collect levels for included projects (normalized keys)
  subprojects { Project sp ->
    String me = normName(sp.name)
    if (!included.contains(me)) return

    int lvl = ((sp.findProperty('projectLevel') ?: 0) as String).toInteger()
    projectLevels[me] = lvl
  }

  // 2) apply dependencies based on levels
  subprojects { Project sp ->
    String me = normName(sp.name)
    if (!included.contains(me)) return

    int myLevel = projectLevels[me] ?: 0

    included.each { String other ->
      if (other == me) return

      int otherLevel = projectLevels[other] ?: 0
      if (myLevel >= otherLevel) {
        sp.dependencies {
          implementation project(":$other")  // âœ… other is already normalized
        }
      }
    }
  }
}
