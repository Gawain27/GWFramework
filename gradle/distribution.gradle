/* =========================================================================
 * Prepare distribution / pathing-jar / run-scripts / archives
 * ========================================================================= */
import groovy.json.JsonOutput
import org.gradle.api.tasks.bundling.Compression

import java.nio.file.Path as NioPath
import java.nio.file.Paths

/* =========================================================================
 * Helpers
 * ========================================================================= */
static String normName(Object o) {
  return o == null ? null : o.toString().trim().toLowerCase(Locale.ROOT)
}

/* ---------------- helper (needs buildVerOf from bump-version.gradle) -- */
Provider<String> starterBuildVersion = project.provider { buildVerOf('gwstarter') }

def jarTaskProviders     = includedProjects.collect { it.tasks.named('jar') }
def projectJarProviders  = includedProjects.findAll { it.name != 'gwstarter' }.collect { it.tasks.named('jar') }

/* ---------------- write config.json + unpack starter ZIP -------------- */
tasks.register('injectProjectVersionIntoConfig') {
  dependsOn jarTaskProviders

  doLast {
    File genDir   = file("$buildDir/generatedConfig/${configSet}-${projectVersion}/bin")
    genDir.mkdirs()
    File jsonFile = new File(genDir, 'config.json')

    List<Map> projectsJson = (parsedConfig.projects ?: []).collect { Map p ->
      String rawName = p.name as String
      String name    = normName(rawName)               // ‚úÖ normalize
      [
        name : name,
        level: (rootProject.projectLevels[name] ?: rootProject.projectLevels[rawName] ?: 0),
        jar  : "lib/${name}-${buildVerOf(name)}.jar",
        type : parsedConfig.gameType
      ]
    } + [
      name : 'gwstarter',
      level: rootProject.projectLevels['gwstarter'] ?: 99,
      jar  : "lib/${configSet}-${projectVersion}-${starterBuildVersion.get()}.jar",
      type : parsedConfig.gameType
    ]

    Map json = [ gameType: parsedConfig.gameType, projects: projectsJson ]
    jsonFile.text = JsonOutput.prettyPrint(JsonOutput.toJson(json))
    println "üìÑ  config.json written ‚Üí $jsonFile"
  }
}

/* =========================================================================
 * Merge every <subproject>/resources/ tree into a single folder and
 * produce one combined assets.txt, resolving clashes by projectLevel.
 *
 *  ‚Ä¢  assetsFinalDir (root gradle.properties) tells us *where* to copy
 *     relative to build/generatedConfig/<configSet>-<version>/bin/
 *  ‚Ä¢  ext.projectLevels (set in dependency-graph.gradle) decides
 *     precedence ‚Äî highest level wins.
 *  ‚Ä¢  runs AFTER all individual assets.txt are written and AFTER the
 *     bin/ folder exists, but BEFORE we package up the distribution.
 * ========================================================================= */
tasks.register('mergeAssets') {
  group       = 'distribution'
  description = 'Collect resources from all sub-projects into one folder with a unified assets.txt'

  dependsOn includedProjects.collect { it.tasks.named('generateAssetsTxt') }
  dependsOn 'injectProjectVersionIntoConfig'   // guarantees binDir exists

  doLast {
    /* ---------- locate the final destination (handles .. and absolute) ---- */
    NioPath binPath   = file("$buildDir/generatedConfig/${configSet}-${projectVersion}/bin").toPath()
    String userDir    = (rootProject.findProperty('assetsFinalDir') ?: 'assets').trim()
    NioPath finalPath = (Paths.get(userDir).isAbsolute()
      ? Paths.get(userDir)
      : binPath.resolve(userDir))
      .normalize()

    File finalDir = finalPath.toFile()
    finalDir.mkdirs()

    println "üì¶  Merging resources into ‚Üí $finalDir"

    /* ---------- pick one ‚Äúwinning‚Äù asset for every path ------------------ */
    Map<String, Map> chosen = [:]   // path ‚Üí [level: int, src: File]

    includedProjects.each { Project p ->
      // ‚úÖ projectLevels is keyed by normalized project name
      String key = normName(p.name)
      int lvl = (rootProject.projectLevels[key] ?: rootProject.projectLevels[p.name] ?: 0) as int

      File txt = file("${p.projectDir}/resources/assets.txt")
      if (!txt.exists()) return

      txt.eachLine { String relPath ->
        if (!relPath) return
        File cand = file("${p.projectDir}/resources/$relPath")
        if (!cand.exists()) return

        Map prev = chosen[relPath]
        if (prev == null || lvl > (prev.level as int)) {
          chosen[relPath] = [ level: lvl, src: cand ]
        }
      }
    }

    /* ---------- copy winners and build the combined manifest ------------- */
    chosen.each { String relPath, Map entry ->
      NioPath destPath = finalPath.resolve(relPath).normalize()
      File dest = destPath.toFile()
      dest.parentFile.mkdirs()
      ant.copy(file: entry.src, tofile: dest, overwrite: true)
    }

    File mergedTxt = finalPath.resolve('assets.txt').toFile()
    mergedTxt.text = chosen.keySet().sort().join('\n') + '\n'
    println "üìÑ  Combined assets.txt written ‚Üí $mergedTxt"
    println "‚úÖ  Copied ${chosen.size()} unique assets."
  }
}

/* ---------------- prepareDistribution  -------------------------------- */
tasks.register('prepareDistribution', Copy) {
  dependsOn project(':gwstarter').tasks.named('distZip'), 'injectProjectVersionIntoConfig'
  dependsOn tasks.named('mergeAssets')

  from zipTree(project(':gwstarter').layout.buildDirectory.file("distributions/gwstarter-${projectVersion}.zip"))
  eachFile { FileCopyDetails fcd ->
    String rootOld = "gwstarter-${projectVersion}"
    String rootNew = "${configSet}-${projectVersion}"
    if (fcd.path.startsWith(rootOld)) fcd.path = fcd.path.replaceFirst(rootOld, rootNew)

    if (fcd.path ==~ /.*\/lib\/gwstarter-\d+\.jar$/) {
      fcd.path = fcd.path.replaceFirst(/gwstarter-\d+\.jar/,
        "${configSet}-${projectVersion}-${starterBuildVersion.get()}.jar")
    }
  }

  includeEmptyDirs = false
  into "$buildDir/generatedConfig"
}

/* =========================================================================
 * Copy model/ data for active configSet projects into final distribution:
 *   model/<subproj>/maps      -> <distro>/data/model/maps
 *   model/<subproj>/templates -> <distro>/data/model/templates
 *   model/<subproj>/worlds    -> <distro>/data/model/worlds
 * ========================================================================= */
tasks.register('copyModelData') {
  group       = 'distribution'
  description = 'Copy model data (maps/templates/worlds) for configSet projects into distribution data/model'

  dependsOn 'prepareDistribution'

  doLast {
    File distroDir = file("$buildDir/generatedConfig/${configSet}-${projectVersion}")
    File modelOut  = new File(distroDir, "data/model")
    File mapsOut   = new File(modelOut, "maps")
    File tempsOut  = new File(modelOut, "templates")
    File worldsOut = new File(modelOut, "worlds")

    mapsOut.mkdirs()
    tempsOut.mkdirs()
    worldsOut.mkdirs()

    // ‚úÖ normalize active project names (matches lowercase include strategy)
    List<String> activeProjects = (parsedConfig.projects ?: [])
      .collect { normName(it.name) }
      .findAll { it != null && !it.isBlank() }

    println "üß©  Copying model data for configSet='${configSet}': ${activeProjects}"

    File modelSrcRoot = file("$rootDir/model")
    if (!modelSrcRoot.exists()) {
      println "‚ö†Ô∏è  No model/ directory found at: $modelSrcRoot (skipping)"
      return
    }

    int copiedCount = 0

    activeProjects.each { String projName ->
      File projRoot = new File(modelSrcRoot, projName)
      if (!projRoot.exists()) {
        println "‚ÑπÔ∏è  No model data for project '$projName' at: $projRoot"
        return
      }

      File srcMaps = new File(projRoot, "maps")
      if (srcMaps.exists()) {
        ant.copy(todir: mapsOut, overwrite: true) { fileset(dir: srcMaps) }
        copiedCount++
        println "  ‚úÖ maps      ‚Üê model/${projName}/maps"
      }

      File srcTemplates = new File(projRoot, "templates")
      if (srcTemplates.exists()) {
        ant.copy(todir: tempsOut, overwrite: true) { fileset(dir: srcTemplates) }
        copiedCount++
        println "  ‚úÖ templates ‚Üê model/${projName}/templates"
      }

      File srcWorlds = new File(projRoot, "worlds")
      if (srcWorlds.exists()) {
        ant.copy(todir: worldsOut, overwrite: true) { fileset(dir: srcWorlds) }
        copiedCount++
        println "  ‚úÖ worlds    ‚Üê model/${projName}/worlds"
      }
    }

    println "üìö  Model copy complete ‚Üí ${modelOut} (segments copied: ${copiedCount})"
  }
}

/* ---------------- copyProjectJarsToDistribution ----------------------- */
tasks.register('copyProjectJarsToDistribution', Copy) {
  dependsOn tasks.named('copyModelData'), jarTaskProviders
  doFirst { println 'üì•  Copying freshly-built jars into distribution ‚Ä¶' }
  from projectJarProviders.collect { it.flatMap { j -> j.archiveFile } }
  into "$buildDir/generatedConfig/${configSet}-${projectVersion}/lib"
  duplicatesStrategy = DuplicatesStrategy.EXCLUDE
}

/* ---------------- createPathingJar ------------------------------------ */
tasks.register('createPathingJar') {
  dependsOn 'copyProjectJarsToDistribution'
  doLast {
    File distroDir = file("$buildDir/generatedConfig/${configSet}-${projectVersion}")
    File binDir    = new File(distroDir, 'bin')
    binDir.mkdirs()
    File libDir    = new File(distroDir, 'lib')
    File launcher  = new File(binDir, 'launcher.jar')

    String libs = (libDir.listFiles() ?: [])
      .findAll { it.name.endsWith('.jar') }
      .collect { "../lib/${it.name}" }
      .sort()
      .join(' ')

    ant.jar(destfile: launcher) {
      manifest {
        attribute(name: 'Manifest-Version', value: '1.0')
        attribute(name: 'Main-Class', value: 'com.gwngames.starter.Starter')
        attribute(name: 'Class-Path', value: libs)
      }
    }
    println "üì¶  Pathing JAR created ‚Üí $launcher"
  }
}

/* ---------------- generateRunScripts ---------------------------------- */
tasks.register('generateRunScripts') {
  dependsOn 'createPathingJar'
  doLast {
    File binDir = file("$buildDir/generatedConfig/${configSet}-${projectVersion}/bin")

    File sh = new File(binDir, 'run.sh')
    sh.text = '''#!/usr/bin/env bash
DIR="$( cd "${BASH_SOURCE%/*}" && pwd )"
"${JAVA_HOME:+$JAVA_HOME/bin/}java" -jar "$DIR/launcher.jar" "$@"
'''
    sh.setExecutable(true)

    File bat = new File(binDir, 'run.bat')
    bat.text = '''@echo off
set DIRNAME=%~dp0
set JAVA=%JAVA_HOME%\\bin\\java.exe
if not exist "%JAVA%" set JAVA=java.exe
"%JAVA%" -jar "%DIRNAME%launcher.jar" %*
'''
    println "üöÄ  run.sh & run.bat written to $binDir"
  }
}

/* ---------------- assembleTestRuntime (shared by test tasks) ---------- */
tasks.register('assembleTestRuntime') {
  dependsOn 'generateRunScripts'
  outputs.dir("$buildDir/generatedConfig/${configSet}-${projectVersion}/bin")
}

/* ---------------- archive tasks --------------------------------------- */
tasks.register('zipDistribution', Zip) {
  dependsOn 'generateRunScripts'
  archiveBaseName.set(configSet)
  archiveVersion.set("${projectVersion}-${starterBuildVersion.get()}")
  destinationDirectory.set(layout.buildDirectory.dir('distributions'))
  from layout.buildDirectory.dir('generatedConfig')
}

tasks.register('tarDistribution', Tar) {
  dependsOn 'generateRunScripts'
  archiveBaseName.set(configSet)
  archiveVersion.set("${projectVersion}-${starterBuildVersion.get()}")
  compression = Compression.GZIP
  destinationDirectory.set(layout.buildDirectory.dir('distributions'))
  from layout.buildDirectory.dir('generatedConfig')
}
