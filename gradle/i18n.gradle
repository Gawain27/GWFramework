/* =========================================================================
 * Global repositories & buildscript deps
 * ========================================================================= */
buildscript {
  repositories {
    mavenCentral()
    gradlePluginPortal()
    mavenLocal()
    google()                                       // Android tool-chain
    maven { url 'https://oss.sonatype.org/content/repositories/snapshots/' }
    maven { url 'https://s01.oss.sonatype.org/content/repositories/snapshots/' }
  }
  dependencies { classpath 'org.ow2.asm:asm:9.7' }
}

allprojects {
  repositories {
    mavenCentral()
    mavenLocal()
    maven { url 'https://oss.sonatype.org/content/repositories/snapshots/' }
    maven { url 'https://s01.oss.sonatype.org/content/repositories/snapshots/' }
    maven { url 'https://jitpack.io' }
  }
}
/* =========================================================================
 * I18N  â€“ scan enums annotated with @Translations and maintain CSV
 * ========================================================================= */


import jdk.internal.org.objectweb.asm.AnnotationVisitor
import jdk.internal.org.objectweb.asm.ClassReader
import jdk.internal.org.objectweb.asm.ClassVisitor
import jdk.internal.org.objectweb.asm.Opcodes
import java.lang.reflect.Method

/* --------------------------------------------------------------------- */
/* Helper methods (unchanged)                                            */
/* --------------------------------------------------------------------- */

static boolean isTranslationsEnum(File classFile) {
  ClassReader cr = new ClassReader(classFile.bytes)
  boolean isEnum = (cr.access & Opcodes.ACC_ENUM) != 0
  if (!isEnum) return false

  boolean found = false
  cr.accept(new ClassVisitor(Opcodes.ASM9) {
    @Override
    AnnotationVisitor visitAnnotation(String desc, boolean visible) {
      if (desc == 'Lcom/gwngames/core/api/build/Translations;') {
        found = true
      }
      return null
    }
  }, ClassReader.SKIP_CODE | ClassReader.SKIP_DEBUG | ClassReader.SKIP_FRAMES)
  return found
}

void ensureAlphabeticOrder(Class<?> enumCls, Project prj) {
  String relPath = enumCls.name.replace('.', '/') + '.java'
  File src = null
  prj.fileTree("${prj.projectDir}/src").matching { include "**/$relPath" }
    .visit { d -> if (!d.directory) src = d.file }

  if (!src) {
    println "   ğŸ”¸ source not found for ${enumCls.name}"
    return
  }

  List<String> lines = src.readLines('UTF-8')
  int decl  = lines.findIndexOf { it.contains("enum ${enumCls.simpleName}") }
  int brace = lines[(decl)..<lines.size()].findIndexOf { it.contains('{') } + decl
  int term  = lines[(brace)..<lines.size()].findIndexOf { it.contains(';') } + brace
  if (decl < 0 || brace < 0 || term < 0) {
    println "      âš  could not parse enum"
    return
  }

  // Collect only the constant lines between â€œ{â€ and â€œ;â€
  List<String> constLines = lines[(brace + 1)..term]
    .findAll { String l ->
      def t = l.trim()
      !(t.isEmpty() || t.startsWith("//"))
    }

  Map<String, String> entryMap = [:]
  constLines.each { String l ->
    String name = l.split(/[,(;]/)[0].trim()
    entryMap[name] = l.trim().replaceAll(/[;,]\s*$/, '')
  }
  List<String> names   = entryMap.keySet().toList()
  List<String> sorted  = names.sort(false)

  if (names == sorted) {
    println "      âœ“ already alphabetical - " + enumCls.getSimpleName()
    return
  }

  // Rebuild the enum-constant block in alphabetical order
  List<String> newBlock = sorted.collect { '\t' + entryMap[it] + ',' }
  newBlock[-1] = newBlock[-1].replaceFirst(/,$/, ';')

  lines.subList(brace + 1, term + 1).clear()
  lines.addAll(brace + 1, newBlock)
  src.withWriter('UTF-8') { w -> lines.each { w.println it } }
  println "   ğŸ”„ rewrote enum â†’ ${enumCls.simpleName}"
}

/* --------------------------------------------------------------------- */
/* Perâ€module â€œupdateTranslationsCsvâ€ task                               */
/* --------------------------------------------------------------------- */
subprojects { Project subproj ->
  if (!includedProjectNames.contains(subproj.name)) return

  tasks.register('updateTranslationsCsv') {
    group       = 'i18n'
    description = 'Scan enums annotated with @Translations and update messages.csv'
    dependsOn   subproj.tasks.named('compileJava')
    mustRunAfter subproj.tasks.named('compileJava')

    doLast {
      println "ğŸ”  ${subproj.path}: scanning for @Translationsâ€¦"

      // (1) Collect all enumâ€class files annotated with @Translations
      List<Map> toLoad = []
      subproj.sourceSets.main.output.classesDirs.files.each { File dir ->
        if (!dir.exists()) return
        dir.eachFileRecurse { File f ->
          if (f.name.endsWith('.class') && isTranslationsEnum(f)) {
            toLoad << [root: dir, file: f]
          }
        }
      }
      if (toLoad.isEmpty()) {
        println "â„¹ï¸  no @Translations enums found."
        return
      }

      // (2) Use a minimal ClassLoader to load those enums
      URL[] urls = subproj.sourceSets.main.output.classesDirs.files
        .collect { it.toURI().toURL() } as URL[]
      ClassLoader loader = new URLClassLoader(urls, (ClassLoader) null)

      Map<String, String> moduleKeys = [:]
      toLoad.each { Map entry ->
        String rel = entry.file.path - entry.root.path - File.separator
        String className = rel.replace(File.separatorChar, '.' as char)
          .replaceAll(/\.class$/, '')
        Class<?> cls = loader.loadClass(className)

        // Autoâ€sort the enum constants in source
        ensureAlphabeticOrder(cls, subproj)

        // Gather key/defaultCaption from each enum constant
        cls.enumConstants.each { Object constant ->
          Method getKeyMeth        = constant.class.getMethod('getKey')
          Method getDefaultMeth    = constant.class.getMethod('getDefaultCaption')
          String key           = getKeyMeth.invoke(constant) as String
          String defaultCap    = getDefaultMeth.invoke(constant) as String
          String where         = "${subproj.path}:${cls.simpleName}"
          String prev          = rootProject.translationKeysGlobal.putIfAbsent(key, where)
          if (prev != null) {
            throw new GradleException(
              "Duplicate translation key '$key': declared in $where, already in $prev"
            )
          }
          moduleKeys[key] = defaultCap
        }
      }

      // (3) Merge into messages.csv
      File csvFile = subproj.file('resources/translation/messages.csv')
      csvFile.parentFile.mkdirs()

      // Read or initialize the header + existing rows
      List<String> header = ['key'] + supportedLocales
      Map<String, List<String>> rows = [:]

      if (csvFile.exists()) {
        csvFile.readLines('UTF-8').withIndex().each { String line, int idx ->
          List<String> cols = line.split(',', -1) as List<String>
          if (idx == 0) {
            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
            // NEW: only keep â€œkeyâ€ plus any preâ€existing columns that are in supportedLocales
            List<String> existingLocales = (cols - 'key')
              .findAll { supportedLocales.contains(it) }
            header = ['key'] + (existingLocales + supportedLocales).unique()
            // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          } else {
            List<String> padded = (cols + [''] * header.size()).take(header.size())
            rows[cols[0]] = padded
          }
        }
      }

      // Figure out which column index corresponds to â€œen_USâ€ (the first supported locale)
      int defaultCol = header.indexOf(supportedLocales[0])
      if (defaultCol < 0) {
        // In case â€œen_USâ€ isnâ€™t literally in the header, fall back to column 1
        defaultCol = 1
      }

      // (4) Populate or create rows; fill in â€œen_USâ€ if blank
      moduleKeys.each { String key, String defaultCap ->
        if (rows.containsKey(key)) {
          // If an â€œen_USâ€ cell is empty, fill it
          List<String> existingRow = rows[key]
          if (existingRow[defaultCol]?.trim() == '') {
            existingRow[defaultCol] = defaultCap
          }
        } else {
          // Brandâ€new key: create a blank row, put key + defaultCap into â€œen_USâ€
          List<String> newRow = [''] * header.size()
          newRow[0] = key
          newRow[defaultCol] = defaultCap
          rows[key] = newRow
        }
      }

      // (5) Write everything back, sorted by key
      csvFile.withWriter('UTF-8') { writer ->
        writer.println header.join(',')
        rows.keySet().sort().each { String k ->
          writer.println rows[k].join(',')
        }
      }
      println "âœ…  ${csvFile} updated â†’ ${moduleKeys.size()} keys scanned; â€˜en_USâ€™ cells populated."
    }
  }

  // Hook into processResources
  subproj.tasks.named('processResources') {
    dependsOn 'updateTranslationsCsv'
  }
}

tasks.register('updateAllTranslations') {
  group       = 'i18n'
  description = 'Update messages.csv in every module'
  dependsOn subprojects.collect { it.tasks.matching { t -> t.name == 'updateTranslationsCsv' } }
}
