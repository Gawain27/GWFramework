/* =========================================================================
 * Global repositories & buildscript deps
 * ========================================================================= */
buildscript {
  repositories {
    mavenCentral()
    gradlePluginPortal()
    mavenLocal()
    google()                                       // Android tool-chain
    maven { url 'https://oss.sonatype.org/content/repositories/snapshots/' }
    maven { url 'https://s01.oss.sonatype.org/content/repositories/snapshots/' }
  }
  dependencies { classpath 'org.ow2.asm:asm:9.7' }
}

allprojects {
  repositories {
    mavenCentral()
    mavenLocal()
    maven { url 'https://oss.sonatype.org/content/repositories/snapshots/' }
    maven { url 'https://s01.oss.sonatype.org/content/repositories/snapshots/' }
    maven { url 'https://jitpack.io' }
  }
}
/* =========================================================================
 * I18N  ‚Äì scan enums annotated with @Translations and maintain CSV
 * ========================================================================= */


import jdk.internal.org.objectweb.asm.AnnotationVisitor
import jdk.internal.org.objectweb.asm.ClassReader
import jdk.internal.org.objectweb.asm.ClassVisitor
import jdk.internal.org.objectweb.asm.Opcodes

import java.lang.reflect.Method

/* --------------------------------------------------------------------- */
/* Helper methods (unchanged)                                            */
/* --------------------------------------------------------------------- */

static boolean isTranslationsEnum(File classFile) {
  ClassReader cr = new ClassReader(classFile.bytes)
  boolean isEnum = (cr.access & Opcodes.ACC_ENUM) != 0
  if (!isEnum) return false

  boolean found = false
  cr.accept(new ClassVisitor(Opcodes.ASM9) {
    @Override
    AnnotationVisitor visitAnnotation(String desc, boolean visible) {
      if (desc == 'Lcom/gwngames/core/api/build/Translations;') {
        found = true
      }
      return null
    }
  }, ClassReader.SKIP_CODE | ClassReader.SKIP_DEBUG | ClassReader.SKIP_FRAMES)
  return found
}

void ensureAlphabeticOrder(Class<?> enumCls, Project prj) {
  String relPath = enumCls.name.replace('.', '/') + '.java'
  File src = null
  prj.fileTree("${prj.projectDir}/src").matching { include "**/$relPath" }
    .visit { d -> if (!d.directory) src = d.file }

  if (!src) {
    println "   üî∏ source not found for ${enumCls.name}"
    return
  }

  List<String> lines = src.readLines('UTF-8')
  int decl  = lines.findIndexOf { it.contains("enum ${enumCls.simpleName}") }
  int brace = lines[(decl)..<lines.size()].findIndexOf { it.contains('{') } + decl
  int term  = lines[(brace)..<lines.size()].findIndexOf { it.contains(';') } + brace
  if (decl < 0 || brace < 0 || term < 0) {
    println "      ‚ö† could not parse enum"
    return
  }

  // Collect only the constant lines between ‚Äú{‚Äù and ‚Äú;‚Äù
  List<String> constLines = lines[(brace + 1)..term]
    .findAll { String l ->
      def t = l.trim()
      !(t.isEmpty() || t.startsWith("//"))
    }

  Map<String, String> entryMap = [:]
  constLines.each { String l ->
    String name = l.split(/[,(;]/)[0].trim()
    entryMap[name] = l.trim().replaceAll(/[;,]\s*$/, '')
  }
  List<String> names   = entryMap.keySet().toList()
  List<String> sorted  = names.sort(false)

  if (names == sorted) {
    println "      ‚úì already alphabetical"
    return
  }

  // Rebuild the enum-constant block in alphabetical order
  List<String> newBlock = sorted.collect { '\t' + entryMap[it] + ',' }
  newBlock[-1] = newBlock[-1].replaceFirst(/,$/, ';')

  lines.subList(brace + 1, term + 1).clear()
  lines.addAll(brace + 1, newBlock)
  src.withWriter('UTF-8') { w -> lines.each { w.println it } }
  println "   üîÑ rewrote enum ‚Üí ${enumCls.simpleName}"
}

/* --------------------------------------------------------------------- */
/* Per‚Äêmodule ‚ÄúupdateTranslationsCsv‚Äù task                               */
/* --------------------------------------------------------------------- */
subprojects { Project subproj ->
  // only run in ‚Äúincluded‚Äù modules
  if (!includedProjectNames.contains(subproj.name)) return

  tasks.register('updateTranslationsCsv') {
    group       = 'i18n'
    description = 'Scan enums annotated with @Translations and update messages.csv'
    dependsOn   subproj.tasks.named('compileJava')
    mustRunAfter subproj.tasks.named('compileJava')

    doLast {
      println "üîç  ${subproj.path}: scanning for @Translations‚Ä¶"

      // (1) Find all .class files that are enums annotated with @Translations
      List<Map> toLoad = []
      subproj.sourceSets.main.output.classesDirs.files.each { File dir ->
        if (!dir.exists()) return
        dir.eachFileRecurse { File f ->
          if (f.name.endsWith('.class') && isTranslationsEnum(f)) {
            toLoad << [root: dir, file: f]
          }
        }
      }

      if (toLoad.isEmpty()) {
        println "‚ÑπÔ∏è  no @Translations enums found."
        return
      }

      // (2) Use a minimal ClassLoader to load each enum
      URL[] urls = subproj.sourceSets.main.output.classesDirs.files
        .collect { it.toURI().toURL() } as URL[]
      ClassLoader loader = new URLClassLoader(urls, (ClassLoader) null)

      // Map<key, defaultCaption> for this module
      Map<String, String> moduleKeys = [:]

      toLoad.each { Map entry ->
        String rel = entry.file.path - entry.root.path - File.separator
        String className = rel
          .replace(File.separatorChar, '.' as char)
          .replaceAll(/\.class$/, '')

        Class<?> cls = loader.loadClass(className)

        // (a) Auto‚Äêsort the enum constants in source
        ensureAlphabeticOrder(cls, subproj)

        // (b) Gather each enum constant‚Äôs key + defaultCaption
        cls.enumConstants.each { Object constant ->
          Method getKeyMeth       = constant.class.getMethod('getKey')
          Method getDefaultMeth   = constant.class.getMethod('getDefaultCaption')
          String key        = getKeyMeth.invoke(constant) as String
          String defaultCap = getDefaultMeth.invoke(constant) as String
          String where      = "${subproj.path}:${cls.simpleName}"
          String prev       = rootProject.translationKeysGlobal.putIfAbsent(key, where)
          if (prev) {
            throw new GradleException(
              "Duplicate translation key '$key': declared in $where, already in $prev"
            )
          }
          moduleKeys[key] = defaultCap
        }
      }

      // (3) Merge into messages.csv
      File csvFile = subproj.file('resources/translation/messages.csv')
      csvFile.parentFile.mkdirs()

      // Read or initialize the header row
      List<String> header = ['key'] + supportedLocales
      Map<String, List<String>> rows = [:]

      if (csvFile.exists()) {
        csvFile.readLines('UTF-8').withIndex().each { String line, int idx ->
          List<String> cols = line.split(',', -1) as List<String>
          if (idx == 0) {
            // Incorporate any new supportedLocales into the existing header.
            header = (['key'] + ((cols - 'key') + supportedLocales)).unique()
          } else {
            List<String> padded = (cols + [''] * header.size()).take(header.size())
            rows[cols[0]] = padded
          }
        }
      }

      //
      // ‚îÄ‚îÄ‚îÄ FORCIBLY ENSURE ‚Äúen_US‚Äù IS AT INDEX 1 ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
      //
      // If ‚Äúen_US‚Äù is not already in the header, insert it immediately after ‚Äúkey.‚Äù
      //
      int enUsIndex = header.indexOf(supportedLocales[0])
      if (enUsIndex != 1) {
        // If it was present somewhere else, remove it first
        if (enUsIndex >= 0) {
          header.remove(enUsIndex)
        }
        // Then insert ‚Äúen_US‚Äù at index 1
        header.add(1, supportedLocales[0])
      }
      // Now definitive location of ‚Äúen_US‚Äù is always 1
      int defaultCol = 1

      // (4) For each discovered key ‚Üí fill in or create row
      moduleKeys.each { String key, String defaultCap ->
        if (rows.containsKey(key)) {
          // Existing row: if its ‚Äúen_US‚Äù cell is blank, fill it
          List<String> existingRow = rows[key]
          if (existingRow[defaultCol]?.trim() == '') {
            existingRow[defaultCol] = defaultCap
          }
        } else {
          // Brand‚Äênew key: create a blank row, put key in col0, defaultCap in ‚Äúen_US‚Äù
          List<String> newRow = [''] * header.size()
          newRow[0] = key
          newRow[defaultCol] = defaultCap
          rows[key] = newRow
        }
      }

      // (5) Write back to messages.csv in sorted‚Äêby‚Äêkey order
      csvFile.withWriter('UTF-8') { writer ->
        writer.println header.join(',')
        rows.keySet().sort().each { String k ->
          writer.println rows[k].join(',')
        }
      }
      println "‚úÖ  ${csvFile} updated ‚Üí ${moduleKeys.size()} keys scanned, ‚Äúen_US‚Äù column populated where needed."
    }
  }

  // Hook it into processResources
  subproj.tasks.named('processResources') {
    dependsOn 'updateTranslationsCsv'
  }
}

/* ‚îÄ‚îÄ‚îÄ umbrella task on root to update every module ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
tasks.register('updateAllTranslations') {
  group       = 'i18n'
  description = 'Update messages.csv in every module'
  dependsOn subprojects.collect { it.tasks.matching { t -> t.name == 'updateTranslationsCsv' } }
}
