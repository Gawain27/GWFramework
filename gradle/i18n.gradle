/* =========================================================================
 * Global repositories & buildscript deps
 * ========================================================================= */
buildscript {
  repositories {
    mavenCentral()
    gradlePluginPortal()
    mavenLocal()
    google()                                       // Android tool-chain
    maven { url 'https://oss.sonatype.org/content/repositories/snapshots/' }
    maven { url 'https://s01.oss.sonatype.org/content/repositories/snapshots/' }
  }
  dependencies { classpath 'org.ow2.asm:asm:9.7' }
}

allprojects {
  repositories {
    mavenCentral()
    mavenLocal()
    maven { url 'https://oss.sonatype.org/content/repositories/snapshots/' }
    maven { url 'https://s01.oss.sonatype.org/content/repositories/snapshots/' }
    maven { url 'https://jitpack.io' }
  }
}
/* =========================================================================
 * I18N  ‚Äì scan enums annotated with @Translations and maintain CSV
 * ========================================================================= */

import jdk.internal.org.objectweb.asm.AnnotationVisitor
import jdk.internal.org.objectweb.asm.ClassReader
import jdk.internal.org.objectweb.asm.ClassVisitor
import jdk.internal.org.objectweb.asm.Opcodes
import java.lang.reflect.Method

/* --------------------------------------------------------------------- */
/* Helper methods (unchanged)                                            */
/* --------------------------------------------------------------------- */

static boolean isTranslationsEnum(File classFile) {
  ClassReader cr = new ClassReader(classFile.bytes)
  boolean isEnum = (cr.access & Opcodes.ACC_ENUM) != 0
  if (!isEnum) return false

  boolean found = false
  cr.accept(new ClassVisitor(Opcodes.ASM9) {
    @Override
    AnnotationVisitor visitAnnotation(String desc, boolean visible) {
      if (desc == 'Lcom/gwngames/core/api/build/Translations;') {
        found = true
      }
      return null
    }
  }, ClassReader.SKIP_CODE | ClassReader.SKIP_DEBUG | ClassReader.SKIP_FRAMES)
  return found
}

void ensureAlphabeticOrder(Class<?> enumCls, Project prj) {
  String relPath = enumCls.name.replace('.', '/') + '.java'
  File src = null
  prj.fileTree("${prj.projectDir}/src").matching { include "**/$relPath" }
    .visit { d -> if (!d.directory) src = d.file }

  if (!src) {
    println "   üî∏ source not found for ${enumCls.name}"
    return
  }

  List<String> lines = src.readLines('UTF-8')
  int decl  = lines.findIndexOf { it.contains("enum ${enumCls.simpleName}") }
  int brace = lines[(decl)..<lines.size()].findIndexOf { it.contains('{') } + decl
  int term  = lines[(brace)..<lines.size()].findIndexOf { it.contains(';') } + brace
  if (decl < 0 || brace < 0 || term < 0) {
    println "      ‚ö† could not parse enum"
    return
  }

  // Collect only the constant lines between ‚Äú{‚Äù and ‚Äú;‚Äù
  List<String> constLines = lines[(brace + 1)..term]
    .findAll { String l ->
      def t = l.trim()
      !(t.isEmpty() || t.startsWith("//"))
    }

  Map<String, String> entryMap = [:]
  constLines.each { String l ->
    String name = l.split(/[,(;]/)[0].trim()
    entryMap[name] = l.trim().replaceAll(/[;,]\s*$/, '')
  }
  List<String> names   = entryMap.keySet().toList()
  List<String> sorted  = names.sort(false)

  if (names == sorted) {
    println "      ‚úì already alphabetical - " + enumCls.getSimpleName()
    return
  }

  // Rebuild the enum-constant block in alphabetical order
  List<String> newBlock = sorted.collect { '\t' + entryMap[it] + ',' }
  newBlock[-1] = newBlock[-1].replaceFirst(/,$/, ';')

  lines.subList(brace + 1, term + 1).clear()
  lines.addAll(brace + 1, newBlock)
  src.withWriter('UTF-8') { w -> lines.each { w.println it } }
  println "   üîÑ rewrote enum ‚Üí ${enumCls.simpleName}"
}

/* --------------------------------------------------------------------- */
/* Per‚Äêmodule ‚ÄúupdateTranslationsCsv‚Äù task                               */
/* --------------------------------------------------------------------- */
subprojects { Project subproj ->
  if (!includedProjectNames.contains(subproj.name)) return

  // Helper: normalize supportedLocales (can be String "en_US,de_DE" or a Collection)
  def normalizeLocales = { obj ->
    if (obj instanceof Collection) {
      return obj.collect { it.toString().trim() }.findAll { it }
    }
    def s = obj == null ? '' : obj.toString().trim()
    return s ? s.split(/\s*,\s*/).collect { it.trim() } : []
  }

  tasks.register('updateTranslationsCsv') {
    group       = 'i18n'
    description = 'Scan enums annotated with @Translations and update messages.csv'
    dependsOn   subproj.tasks.named('compileJava')
    mustRunAfter subproj.tasks.named('compileJava')

    doLast {
      // Always use a normalized List<String> for supported locales
      List<String> SUP = normalizeLocales(rootProject.hasProperty('supportedLocales')
        ? rootProject.property('supportedLocales')
        : supportedLocales)

      println "üîç  ${subproj.path}: scanning for @Translations‚Ä¶"

      // (1) Collect all enum‚Äêclass files annotated with @Translations
      List<Map> toLoad = []
      subproj.sourceSets.main.output.classesDirs.files.each { File dir ->
        if (!dir.exists()) return
        dir.eachFileRecurse { File f ->
          if (f.name.endsWith('.class') && isTranslationsEnum(f)) {
            toLoad << [root: dir, file: f]
          }
        }
      }
      if (toLoad.isEmpty()) {
        println "‚ÑπÔ∏è  no @Translations enums found."
        return
      }

      // (2) Use a minimal ClassLoader to load those enums
      URL[] urls = subproj.sourceSets.main.output.classesDirs.files
        .collect { it.toURI().toURL() } as URL[]
      ClassLoader loader = new URLClassLoader(urls, (ClassLoader) null)

      Map<String, String> moduleKeys = [:]
      toLoad.each { Map entry ->
        String rel = entry.file.path - entry.root.path - File.separator
        String className = rel.replace(File.separatorChar, '.' as char)
          .replaceAll(/\.class$/, '')
        Class<?> cls = loader.loadClass(className)

        // Auto‚Äêsort the enum constants in source
        ensureAlphabeticOrder(cls, subproj)

        // Gather key/defaultCaption from each enum constant
        cls.enumConstants.each { Object constant ->
          Method getKeyMeth     = constant.class.getMethod('getKey')
          Method getDefaultMeth = constant.class.getMethod('getDefaultCaption')
          String key        = getKeyMeth.invoke(constant) as String
          String defaultCap = getDefaultMeth.invoke(constant) as String
          String where      = "${subproj.path}:${cls.simpleName}"
          String prev       = rootProject.translationKeysGlobal.putIfAbsent(key, where)
          if (prev != null) {
            throw new GradleException(
              "Duplicate translation key '$key': declared in $where, already in $prev"
            )
          }
          moduleKeys[key] = defaultCap
        }
      }

      // (3) Merge into messages.csv
      File csvFile = subproj.file('resources/translation/messages.csv')
      csvFile.parentFile.mkdirs()

      // Read or initialize the header + existing rows
      List<String> header = ['key'] + SUP
      Map<String, List<String>> rows = [:]

      if (csvFile.exists()) {
        csvFile.readLines('UTF-8').withIndex().each { String line, int idx ->
          // split preserving empty columns, then normalize
          List<String> cols = (line.split(',', -1) as List<String>).collect { it.trim() }
          if (idx == 0) {
            // strip BOM on first column just in case
            if (!cols.isEmpty()) cols[0] = cols[0].replace('\uFEFF', '').trim()

            // keep only supported locales already present in header
            List<String> existingLocales = (cols - 'key').findAll { SUP.contains(it) }

            // merge with SUP, FLATTEN, TRIM, UNIQUE ‚Äî prevents duplication & char-splitting
            List<String> merged = (existingLocales + SUP)
              .flatten()
              .collect { it.trim() }
              .unique()

            header = ['key'] + merged
          } else {
            // pad/truncate to current header length
            List<String> padded = (cols + [''] * header.size()).take(header.size())
            rows[cols[0]] = padded
          }
        }
      }

      // Column for default locale (first supported)
      int defaultCol = header.indexOf(SUP ? SUP[0] : 'en_US')
      if (defaultCol < 0) defaultCol = 1  // fallback if header lacked it

      // (4) Populate or create rows; fill default locale if blank
      moduleKeys.each { String key, String defaultCap ->
        if (rows.containsKey(key)) {
          List<String> existingRow = rows[key]
          if ((existingRow[defaultCol] ?: '').trim() == '') {
            existingRow[defaultCol] = defaultCap
          }
        } else {
          List<String> newRow = [''] * header.size()
          newRow[0] = key
          newRow[defaultCol] = defaultCap
          rows[key] = newRow
        }
      }

      // (5) Write everything back, sorted by key
      csvFile.withWriter('UTF-8') { writer ->
        writer.println header.join(',')
        rows.keySet().sort().each { String k ->
          List<String> row = rows[k]
          if (row.size() != header.size()) {
            row = (row + [''] * header.size()).take(header.size())
          }
          writer.println row.join(',')
        }
      }
      println "‚úÖ  ${csvFile} updated ‚Üí ${moduleKeys.size()} keys scanned; default-locale cells populated."
    }
  }

  // Hook into processResources
  subproj.tasks.named('processResources') {
    dependsOn 'updateTranslationsCsv'
  }
}

tasks.register('updateAllTranslations') {
  group       = 'i18n'
  description = 'Update messages.csv in every module'
  dependsOn subprojects.collect { it.tasks.matching { t -> t.name == 'updateTranslationsCsv' } }
}
