import java.security.MessageDigest

/* =========================================================================
 * Common sub-project convention (plugins, Java version, JAR naming)
 * ========================================================================= */

static String normName(Object o) {
  return o == null ? null : o.toString().trim().toLowerCase(Locale.ROOT)
}

final Set<String> included = (includedProjectNames ?: [])
  .collect { normName(it) }
  .findAll { it }
  .toSet()

subprojects { Project subproj ->
  if (!included.contains(normName(subproj.name))) return

  def isRemoteAssetsConfigured = {
    File propsFile = project.file('gradle.properties')
    if (!propsFile.exists()) return false

    Properties props = new Properties()
    propsFile.withInputStream { props.load(it) }

    String urlKey = "${project.name.toLowerCase(Locale.ROOT)}_url"
    String remoteUrl = (props.getProperty(urlKey) ?: '').trim()

    return remoteUrl && remoteUrl != 'null'
  }

  apply plugin: 'java'
  apply plugin: 'java-library'
  apply plugin: 'idea'
  apply plugin: 'eclipse'

  // Treat <subproject>/src as an additional source root
  sourceSets.main.java.srcDir 'src'

  sourceCompatibility = JavaVersion.VERSION_21
  targetCompatibility = JavaVersion.VERSION_21
  version = projectVersion                       // from gradle.properties

  /* ------------------------------------------------------------ */
  /*  Extra test-JAR artefact                                     */
  /* ------------------------------------------------------------ */
  plugins.withType(JavaPlugin).configureEach {
    configurations { testOutput }
    tasks.register('testJar', Jar) {
      archiveClassifier.set('tests')
      from sourceSets.test.output
    }
    artifacts { testOutput testJar }
  }

  /* ------------------------------------------------------------ */
  /*  JAR naming + buildVersion bump on shipping builds           */
  /* ------------------------------------------------------------ */
  tasks.named('jar') { Jar jarTask ->
    if (rootProject.isShippingBuild) {
      dependsOn rootProject.tasks.named('bumpBuildVersions')
      outputs.upToDateWhen { false }          // force rebuild
    }
    doFirst {
      Properties p = new Properties()
      file("${projectDir}/gradle.properties").withInputStream { p.load(it) }
      archiveFileName.set("${subproj.name}-${p.getProperty('buildVersion')}.jar")
    }
  }

  /* ────────────────────────────────────────────────────────────────────────────
   * Keep <subproject>/resources in sync with the ZIP produced by a Dropbox
   * link stored in THIS subproject gradle.properties as <subproject>_url.
   * ──────────────────────────────────────────────────────────────────────────── */
  tasks.register('updateResources') {
    group       = 'build'
    description = 'Sync <subproject>/resources with the Dropbox archive defined in this subproject gradle.properties'

    // per-subproject gradle.properties (NOT root)
    File       propsFile = project.file('gradle.properties')
    Properties props     = new Properties()

    if (!propsFile.exists()) {
      throw new GradleException("Missing ${project.path} gradle.properties at: ${propsFile}")
    }
    propsFile.withInputStream { props.load(it) }

    String urlKey  = "${project.name.toLowerCase(Locale.ROOT)}_url"
    String hashKey = "${project.name.toLowerCase(Locale.ROOT)}_hash"

    // ensure keys exist in the SUBPROJECT properties file
    boolean mutated = false
    if (!props.containsKey(urlKey))  { props[urlKey]  = 'null'; mutated = true }
    if (!props.containsKey(hashKey)) { props[hashKey] = '';     mutated = true }
    if (mutated) propsFile.withOutputStream { props.store(it, null) }

    String remoteUrl = props[urlKey]
    if (!remoteUrl || remoteUrl == 'null') {
      logger.lifecycle("No ${urlKey} configured – skipping download for ${project.path}")
      return
    }

    // serialize tasks touching this module’s properties file (safe for parallel)
    inputs.file(propsFile)
    outputs.file(propsFile)

    String remoteHash = fetchRemoteHash(remoteUrl)
    String localHash  = props[hashKey]

    if (remoteHash && remoteHash == localHash) {
      logger.lifecycle("Resources for ${project.path} already up to date (hash $remoteHash)")
      return
    }

    /* ---------- download the ZIP ------------------------------------------- */
    File dlDir   = rootProject.file("$buildDir/downloads"); dlDir.mkdirs()
    File archive = new File(dlDir, "${project.name}-resources.zip")
    logger.lifecycle("Downloading updated resources for ${project.path} …")

    new URL(remoteUrl).withInputStream { ins ->
      archive.withOutputStream { out -> out << ins }
    }

    /* ---------- compute fallback SHA-256 if server gave no hash ------------ */
    if (!remoteHash) {
      remoteHash = archive.withInputStream { stream ->
        MessageDigest md = MessageDigest.getInstance('SHA-256')
        byte[] buf = new byte[8192]; int n
        while ((n = stream.read(buf)) > 0) md.update(buf, 0, n)
        md.digest().encodeHex().toString()
      }
    }

    /* ---------- unpack & locate the resources folder ---------------------- */
    File tmpDir = file("$buildDir/tmp/${project.name}-resources")
    tmpDir.deleteDir(); tmpDir.mkdirs()

    ant.unzip(src: archive, dest: tmpDir, overwrite: 'true')

    File srcRoot = new File(tmpDir, 'resources')
    if (!srcRoot.exists()) {
      File maybe = tmpDir.listFiles()
        ?.find { new File(it, 'resources').exists() }
        ?.with { new File(it, 'resources') }
      srcRoot = maybe ?: srcRoot
    }

    if (!srcRoot.exists()) {
      throw new GradleException(
        "Archive for ${project.path} does not contain a 'resources/' directory"
      )
    }

    /* ---------- copy new/changed files into the real resources dir -------- */
    copy {
      from srcRoot
      into "$projectDir/resources"
      includeEmptyDirs = false
      duplicatesStrategy = DuplicatesStrategy.INCLUDE
    }
    tmpDir.deleteDir()

    /* ---------- persist the new hash back to SUBPROJECT gradle.properties --- */
    props[hashKey] = remoteHash
    propsFile.withOutputStream { props.store(it, null) }

    logger.lifecycle("✓  Synced resources for ${project.path}; stored hash ${remoteHash.take(10)}…")
  }

  /* ------------------------------------------------------------ */
  /* 1)  Write assets.txt with a flat list of every resource file */
  /* ------------------------------------------------------------ */
  tasks.register('generateAssetsTxt') { Task t ->
    group       = 'build'
    description = 'List all files under resources into assets.txt'
    dependsOn tasks.named('updateResources')

    onlyIf { isRemoteAssetsConfigured() }

    inputs.files(sourceSets.main.resources)
    outputs.file("${projectDir}/resources/assets.txt")

    doLast {
      File resRoot = sourceSets.main.resources.srcDirs.find { it.exists() } as File
      if (!resRoot) {
        logger.lifecycle("No resources for ${project.path}, skipping assets.txt")
        return
      }

      File outFile = new File(resRoot, 'assets.txt')
      def relPaths = fileTree(resRoot) {
        include '**/*.*'
      }.files.collect { f ->
        resRoot.toPath().relativize(f.toPath()).toString().replace('\\', '/')
      }.sort()

      outFile.text = relPaths.join('\n') + '\n'
      logger.lifecycle("Wrote ${relPaths.size()} entries to ${outFile}")
    }
  }

  /* ------------------------------------------------------------ */
  /* 2)  Turn assets.txt into enum classes under src/… (+locales) */
  /* ------------------------------------------------------------ */
  tasks.register('generateAssetEnums') {
    group       = 'build'
    description = 'Create enum classes that mirror the resources tree, collapsing locale variants into a single constant'
    dependsOn   tasks.named('generateAssetsTxt')

    onlyIf { isRemoteAssetsConfigured() }

    final File srcRoot = file("$projectDir/src/com/gwngames/assets")

    /* ---- locale set ------------------------------------------------------- */
    Properties p = new Properties()
    File localPropsFile = file("$projectDir/gradle.properties")
    if (localPropsFile.exists()) {
      p.load(localPropsFile.newInputStream())
    }
    Set<String> supportedLocales = new HashSet<>(
      (p.getProperty('supportedLocales', '')).tokenize(',')
    )

    inputs.file  "${projectDir}/resources/assets.txt"
    outputs.dir  srcRoot

    doFirst {
      if (srcRoot.exists()) srcRoot.deleteDir()
    }

    doLast {
      // also protect against empty/missing assets.txt
      File assetsTxt = file("${projectDir}/resources/assets.txt")
      if (!assetsTxt.exists() || assetsTxt.text.trim().isEmpty()) {
        logger.lifecycle("ℹ️  No assets.txt entries for ${project.path}, skipping asset enum generation.")
        return
      }

      srcRoot.mkdirs()

      /* key = [pkgSuffix, clsName, baseFileName] */
      Map<List<String>, List<Map>> buckets = [:]

      file("${projectDir}/resources/assets.txt").eachLine { String rel ->
        int slash      = rel.lastIndexOf('/')
        String dirPart = slash > -1 ? rel.substring(0, slash) : ''
        String filePart= slash > -1 ? rel.substring(slash + 1) : rel

        /* -------- locale detection ------------------------------------ */
        String locale   = null
        String basePart = filePart
        supportedLocales.each { loc ->
          if (filePart.startsWith(loc + '_')) {
            locale   = loc
            basePart = filePart.substring(loc.length() + 1)
          }
        }

        List<String> tokens  = dirPart ? dirPart.tokenize('/') : []
        String baseName      = tokens ? tokens[-1] : ''
        String pkgSuffix     = dirPart ? '.' + dirPart.replace('/', '.') : ''
        String cls           = toPascal(project.name) + toPascal(baseName) + 'Assets'

        buckets.computeIfAbsent([pkgSuffix, cls, basePart]) { [] } << [
          dir   : dirPart,
          file  : filePart,
          base  : basePart,
          locale: locale
        ]
      }

      /* -------- emit one enum per bucket --------------------------------- */
      buckets.groupBy { it.key[0..1] }
        .each { pcKey, groups ->

          String pkgSuffix = pcKey[0].replace('-', '')
          String cls       = pcKey[1]

          File outDir = new File(srcRoot, pkgSuffix.replace('.', '/'))
          outDir.mkdirs()
          File javaFile = new File(outDir, "${cls}.java")

          String enumConstants = groups.collect { entry ->
            List<Map> items  = entry.value
            String constName = entry.key[2].replaceAll('[^A-Za-z0-9]','_').toUpperCase()

            if (items*.locale.findAll().size() > 0) {
              String locMap = items.collect { i ->
                "\"${i.locale ?: 'default'}\", \"${i.dir ? i.dir + '/' : ''}${i.file}\""
              }.join(", ")
              return """    ${constName}(\"${items[0].base}\", java.util.Map.of(${locMap}))"""
            } else {
              String path = "${items[0].dir ? items[0].dir + '/' : ''}${items[0].file}"
              return "    ${constName}(\"${path}\")"
            }
          }.join(",\n")

          javaFile.text = """// *** GENERATED FILE – DO NOT EDIT ***
package com.gwngames.assets${pkgSuffix};

import java.util.*;
import com.gwngames.core.api.asset.IAssetPath;

public enum ${cls} implements IAssetPath {
${enumConstants};

    private final String defaultPath;
    private final Map<String,String> localePaths;

    ${cls}(String path) {
        this.defaultPath = path;
        this.localePaths = Map.of();
    }
    ${cls}(String baseName, Map<String,String> localePaths) {
        this.defaultPath = baseName;
        this.localePaths = Collections.unmodifiableMap(localePaths);
    }

    /** path for the default (non-localised) resource */
    public String path() { return defaultPath; }

    /** path for a specific locale or fall back to default */
    public String path(String locale) {
        return localePaths.getOrDefault(locale, defaultPath);
    }

    /** list of locales explicitly provided for this asset */
    public List<String> locales() {
        return List.copyOf(localePaths.keySet());
    }

    @Override public String toString() { return path(); }
}
""".stripIndent()
        }

      logger.lifecycle("✅  Asset enums written to ${srcRoot}")
    }
  }

  /* ------------------------------------------------------------ */
  /* 3)  Wire tasks into the build                               */
  /* ------------------------------------------------------------ */
  tasks.named('compileJava') { dependsOn tasks.named('generateAssetEnums') }
  tasks.named('processResources').configure { dependsOn tasks.named('generateAssetsTxt') }
}

/* ---- helpers ----------------------------------------------------------- */
static String toPascal(String s) {
  s.split(/[^A-Za-z0-9]+/)
    .findAll { it }
    .collect { tok ->
      if (tok.length() <= 2 || tok =~ /[0-9]/ || tok == tok.toUpperCase()) {
        tok.toUpperCase()
      } else {
        tok[0].toUpperCase() + tok.substring(1).toLowerCase()
      }
    }
    .join('')
}

/* ---------- helper: follow redirects & grab ETag (or fallback) --------- */
String fetchRemoteHash(String url, int depth = 0) {
  if (depth > 5) throw new GradleException("Too many redirects for $url")

  HttpURLConnection c = (HttpURLConnection) new URL(url).openConnection()
  c.instanceFollowRedirects = false
  c.requestMethod  = 'HEAD'
  c.connectTimeout = 15_000
  c.readTimeout    = 15_000
  c.setRequestProperty('User-Agent', 'GradleResourceSync/1.0')
  c.connect()

  int code = c.responseCode
  if (code in [301, 302, 303, 307, 308]) {
    String loc = c.getHeaderField('Location')
    c.disconnect()
    return fetchRemoteHash(loc, depth + 1)
  }

  String etag = c.getHeaderField('ETag')?.replace('"', '')
  if (!etag) etag = c.getHeaderField('Content-MD5')
  if (!etag) etag = c.getHeaderField('Last-Modified')
  if (!etag) etag = c.getHeaderField('Content-Length')
  c.disconnect()
  return etag ?: ''
}
