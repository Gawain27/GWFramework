import java.security.MessageDigest

/* =========================================================================
 * Common sub-project convention (plugins, Java version, JAR naming)
 * ========================================================================= */
subprojects { Project subproj ->
  if (!includedProjectNames.contains(subproj.name)) return

  apply plugin: 'java'
  apply plugin: 'java-library'
  apply plugin: 'idea'
  apply plugin: 'eclipse'

  // Treat <subproject>/src as an additional source root
  sourceSets.main.java.srcDir 'src'

  sourceCompatibility = JavaVersion.VERSION_21
  targetCompatibility = JavaVersion.VERSION_21
  version = projectVersion                       // from gradle.properties

  /* ------------------------------------------------------------ */
  /*  Extra test-JAR artefact                                     */
  /* ------------------------------------------------------------ */
  plugins.withType(JavaPlugin).configureEach {
    configurations { testOutput }
    tasks.register('testJar', Jar) {
      archiveClassifier.set('tests')
      from sourceSets.test.output
    }
    artifacts { testOutput testJar }
  }

  /* ------------------------------------------------------------ */
  /*  JAR naming + buildVersion bump on shipping builds           */
  /* ------------------------------------------------------------ */
  tasks.named('jar') { Jar jarTask ->
    if (rootProject.isShippingBuild) {
      dependsOn rootProject.tasks.named('bumpBuildVersions')
      outputs.upToDateWhen { false }          // force rebuild
    }
    doFirst {
      Properties p = new Properties()
      file("${projectDir}/gradle.properties").withInputStream { p.load(it) }
      archiveFileName.set("${subproj.name}-${p.getProperty('buildVersion')}.jar")
    }
  }

  /* ────────────────────────────────────────────────────────────────────────────
  *  Keep <subproject>/resources in sync with the ZIP produced by a OneDrive
  *  folder link stored in ROOT gradle.properties as <subproject>_url.
  * ──────────────────────────────────────────────────────────────────────────── */
  tasks.register('updateResources') {
    group       = 'build'
    description = 'Sync <subproject>/resources with the Dropbox archive defined in root gradle.properties'

    /* ---------- shared gradle.properties at repo root ---------------------- */
    File       rootPropsFile = rootProject.file('gradle.properties')
    Properties rootProps     = new Properties().tap { rootPropsFile.withInputStream { load(it) } }

    String urlKey  = "${project.name.toLowerCase()}_url"
    String hashKey = "${project.name.toLowerCase()}_hash"

    /* ---------- ensure the keys exist -------------------------------------- */
    boolean mutated = false
    if (!rootProps.containsKey(urlKey))  { rootProps[urlKey]  = 'null'; mutated = true }
    if (!rootProps.containsKey(hashKey)) { rootProps[hashKey] = '';     mutated = true }
    if (mutated) rootPropsFile.withOutputStream { rootProps.store(it, null) }

    String remoteUrl = rootProps[urlKey]
    if (!remoteUrl || remoteUrl == 'null') {
      logger.lifecycle("No ${urlKey} configured – skipping download for ${project.path}")
      return
    }

    /* ---------- make the task serialisable for parallel builds ------------- */
    outputs.file(rootPropsFile)   // Gradle serialises tasks touching this file

    String remoteHash = fetchRemoteHash(remoteUrl)
    String localHash  = rootProps[hashKey]

    if (remoteHash && remoteHash == localHash) {
      logger.lifecycle("Resources for ${project.path} already up to date (hash $remoteHash)")
      return
    }

    /* ---------- download the ZIP ------------------------------------------- */
    File dlDir   = rootProject.file("$buildDir/downloads"); dlDir.mkdirs()
    File archive = new File(dlDir, "${project.name}-resources.zip")
    logger.lifecycle("Downloading updated resources for ${project.path} …")

    new URL(remoteUrl).withInputStream { ins ->
      archive.withOutputStream { out -> out << ins }        //  ◄─  Groovy-style copy
    }

    /* ---------- compute fallback SHA-256 if server gave no hash ------------ */
    if (!remoteHash) {
      remoteHash = archive.withInputStream { stream ->
        MessageDigest md = MessageDigest.getInstance('SHA-256')
        byte[] buf = new byte[8192]; int n
        while ((n = stream.read(buf)) > 0) md.update(buf, 0, n)
        md.digest().encodeHex().toString()
      }
    }

    /* ---------- unpack & locate the resources folder ---------------------- */
    File tmpDir = file("$buildDir/tmp/${project.name}-resources")
    tmpDir.deleteDir(); tmpDir.mkdirs()

    // Use Ant – it’s tolerant of weird encodings & huge ZIPs
    ant.unzip(src: archive, dest: tmpDir, overwrite: 'true')

    // Try <tmp>/resources first; if absent, look one level deeper
    File srcRoot = new File(tmpDir, 'resources')
    if (!srcRoot.exists()) {
      File maybe = tmpDir.listFiles()
        ?.find { new File(it, 'resources').exists() }
        ?.with { new File(it, 'resources') }
      srcRoot = maybe ?: srcRoot
    }

    if (!srcRoot.exists()) {
      throw new GradleException(
        "Archive for ${project.path} does not contain a 'resources/' directory"
      )
    }

    /* ---------- copy new/changed files into the real resources dir -------- */
    copy {
      from srcRoot
      into "$projectDir/resources"
      includeEmptyDirs = false
      duplicatesStrategy = DuplicatesStrategy.INCLUDE
    }
    tmpDir.deleteDir()

    /* ---------- persist the new hash back to root gradle.properties ------- */
    rootProps[hashKey] = remoteHash
    rootPropsFile.withOutputStream { rootProps.store(it, null) }

    logger.lifecycle("✓  Synced resources for ${project.path}; stored hash ${remoteHash.take(10)}…")

  }

  /* ------------------------------------------------------------ */
  /* 1)  Write assets.txt with a flat list of every resource file */
  /* ------------------------------------------------------------ */
  tasks.register('generateAssetsTxt') { Task t ->
    group       = 'build'
    description = 'List all files under resources into assets.txt'
    dependsOn tasks.named('updateResources')

    inputs.files(sourceSets.main.resources)
    outputs.file("${projectDir}/resources/assets.txt")

    doLast {
      File resRoot = sourceSets.main.resources.srcDirs.find { it.exists() } as File
      if (!resRoot) {
        logger.lifecycle("No resources for ${project.path}, skipping assets.txt")
        return
      }

      File outFile = new File(resRoot, 'assets.txt')
      def relPaths = fileTree(resRoot) {
        include '**/*.*'
      }.files.collect { f ->
        resRoot.toPath().relativize(f.toPath()).toString().replace('\\', '/')
      }.sort()

      outFile.text = relPaths.join('\n') + '\n'
      logger.lifecycle("Wrote ${relPaths.size()} entries to ${outFile}")
    }
  }

  /* ------------------------------------------------------------ */
  /* 2)  Turn assets.txt into enum classes under src/… (+locales) */
  /* ------------------------------------------------------------ */
  tasks.register('generateAssetEnums') {
    group       = 'build'
    description = 'Create enum classes that mirror the resources tree, ' +
      'collapsing locale variants into a single constant'
    dependsOn   tasks.named('generateAssetsTxt')

    final File srcRoot = file("$projectDir/src/com/gwngames/assets")

    /* ---- locale set ------------------------------------------------------- */
    Properties p = new Properties()
    p.load(file("$projectDir/gradle.properties").newInputStream())
    Set<String> supportedLocales = new HashSet<>(p.getProperty('supportedLocales', '')
      .tokenize(','))

    /* ---- inputs & outputs ------------------------------------------------- */
    inputs.file  "${projectDir}/resources/assets.txt"
    outputs.dir  srcRoot

    doFirst {
      if (srcRoot.exists()) srcRoot.deleteDir()
    }

    doLast {
      srcRoot.mkdirs()

      /* key = [pkgSuffix, clsName, baseFileName] */
      Map<List<String>, List<Map>> buckets = [:]

      file("${projectDir}/resources/assets.txt").eachLine { String rel ->
        int slash      = rel.lastIndexOf('/')
        String dirPart = slash > -1 ? rel.substring(0, slash) : ''
        String filePart= slash > -1 ? rel.substring(slash + 1) : rel

        /* -------- locale detection ------------------------------------ */
        String locale    = null
        String basePart  = filePart
        supportedLocales.each { loc ->
          if (filePart.startsWith(loc + '_')) {
            locale   = loc
            basePart = filePart.substring(loc.length() + 1)   // strip "<loc>_"
          }
        }

        List<String> tokens  = dirPart ? dirPart.tokenize('/') : []
        String baseName      = tokens ? tokens[-1] : ''
        String pkgSuffix     = dirPart ? '.' + dirPart.replace('/', '.') : ''
        String cls           = toPascal(project.name) + toPascal(baseName) + 'Assets'

        buckets.computeIfAbsent([pkgSuffix, cls, basePart]) { [] }
          << [dir: dirPart,
              file: filePart,
              base: basePart,
              locale: locale]
      }

      /* -------- emit one enum per bucket --------------------------------- */
      buckets.groupBy { it.key[0..1] }      // group by [pkgSuffix, cls]
        .each { pcKey, groups ->

          String pkgSuffix = pcKey[0].replace('-', '')
          String cls       = pcKey[1]

          File outDir = new File(srcRoot, pkgSuffix.replace('.', '/'))
          outDir.mkdirs()
          File javaFile = new File(outDir, "${cls}.java")

          String enumConstants = groups.collect { entry ->
            List<Map> items   = entry.value
            String constName  = entry.key[2].replaceAll('[^A-Za-z0-9]','_')
              .toUpperCase()

            if (items*.locale.findAll().size() > 0) {         // at least one locale
              String locMap = items.collect { i ->
                "\"${i.locale ?: 'default'}\", \"${i.dir ? i.dir + '/' : ''}${i.file}\""
              }.join(", ")
              return """    ${constName}(\"${items[0].base}\", java.util.Map.of(${locMap}))"""
            } else {                                          // non-localised
              String path = "${items[0].dir ? items[0].dir + '/' : ''}${items[0].file}"
              return "    ${constName}(\"${path}\")"
            }
          }.join(",\n")

          javaFile.text = """// *** GENERATED FILE – DO NOT EDIT ***
package com.gwngames.assets${pkgSuffix};

import java.util.*;
import com.gwngames.core.api.asset.IAssetPath;

public enum ${cls} implements IAssetPath {
${enumConstants};

    private final String defaultPath;
    private final Map<String,String> localePaths;

    ${cls}(String path) {
        this.defaultPath = path;
        this.localePaths = Map.of();
    }
    ${cls}(String baseName, Map<String,String> localePaths) {
        this.defaultPath = baseName;
        this.localePaths = Collections.unmodifiableMap(localePaths);
    }

    /** path for the default (non-localised) resource */
    public String path() { return defaultPath; }

    /** path for a specific locale or fall back to default */
    public String path(String locale) {
        return localePaths.getOrDefault(locale, defaultPath);
    }

    /** list of locales explicitly provided for this asset */
    public List<String> locales() {
        return List.copyOf(localePaths.keySet());
    }

    @Override public String toString() { return path(); }
}
""".stripIndent()
        }

      logger.lifecycle("✅  Asset enums written to ${srcRoot}")
    }
  }


  /* ------------------------------------------------------------ */
  /* 3)  Wire tasks into the build                               */
  /* ------------------------------------------------------------ */
  tasks.named('compileJava')    { dependsOn tasks.named('generateAssetEnums') }
  tasks.named('processResources').configure {
    dependsOn tasks.named('generateAssetsTxt')
  }
}

/* ---- helpers ----------------------------------------------------------- */
static String toPascal(String s) {
  s.split(/[^A-Za-z0-9]+/)
    .findAll { it }                              // drop empties
    .collect { tok ->
      if (tok.length() <= 2 || tok =~ /[0-9]/ || tok == tok.toUpperCase()) {
        tok.toUpperCase()                   // keep acronyms & things with digits
      } else {
        tok[0].toUpperCase() + tok.substring(1).toLowerCase()
      }
    }
    .join('')
}

/* ---------- helper: follow redirects & grab ETag (or fallback) --------- */
String fetchRemoteHash(String url, int depth = 0) {
  if (depth > 5) throw new GradleException("Too many redirects for $url")

  HttpURLConnection c = (HttpURLConnection) new URL(url).openConnection()
  c.instanceFollowRedirects = false      // we handle redirects manually
  c.requestMethod  = 'HEAD'
  c.connectTimeout = 15_000
  c.readTimeout    = 15_000
  c.setRequestProperty('User-Agent', 'GradleResourceSync/1.0')
  c.connect()

  int code = c.responseCode
  if (code in [301, 302, 303, 307, 308]) {
    String loc = c.getHeaderField('Location')
    c.disconnect()
    return fetchRemoteHash(loc, depth + 1)
  }

  String etag = c.getHeaderField('ETag')?.replace('"', '')
  if (!etag) etag = c.getHeaderField('Content-MD5')
  if (!etag) etag = c.getHeaderField('Last-Modified')
  if (!etag) etag = c.getHeaderField('Content-Length')
  c.disconnect()
  return etag ?: ''
}
