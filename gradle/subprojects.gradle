/* =========================================================================
 * Common sub-project convention (plugins, Java version, JAR naming)
 * ========================================================================= */
subprojects { Project subproj ->
  if (!includedProjectNames.contains(subproj.name)) return

  apply plugin: 'java'
  apply plugin: 'java-library'
  apply plugin: 'idea'
  apply plugin: 'eclipse'

  sourceCompatibility = JavaVersion.VERSION_21
  targetCompatibility = JavaVersion.VERSION_21
  version = projectVersion                         // from gradle.properties

  plugins.withType(JavaPlugin).configureEach {
    // 1) Add a new configuration to hold test‐classes
    configurations {
      testOutput
    }
    // 2) Create the JAR task from the test source set
    tasks.register('testJar', Jar) {
      archiveClassifier.set('tests')
      from sourceSets.test.output
    }
    // 3) Publish it on testOutput
    artifacts {
      testOutput testJar
    }
  }
  /* -------------------------------------------------------------- */
  // JAR naming and buildVersion bump on shipping builds
  /* -------------------------------------------------------------- */
  tasks.named('jar') { Jar jarTask ->
    if (rootProject.isShippingBuild) {
      dependsOn rootProject.tasks.named('bumpBuildVersions')
      outputs.upToDateWhen { false }           // force rebuild
    }
    doFirst {
      Properties p = new Properties()
      file("${projectDir}/gradle.properties").withInputStream { p.load(it) }
      archiveFileName.set("${subproj.name}-${p.getProperty('buildVersion')}.jar")
    }
  }

  /* ------------------------------------------------------------------ */
  /*  Generate assets.txt with a flat list of every resource file       */
  /* ------------------------------------------------------------------ */
  tasks.register('generateAssetsTxt') { Task t ->
    group       = 'build'
    description = 'List all files under resources into assets.txt'

    // --- inputs & outputs for incremental builds -------------------
    inputs.files(sourceSets.main.resources)
    outputs.file("${projectDir}/resources/assets.txt")

    // --- work -------------------------------------------------------
    doLast {
      // Pick the first existing resource root (handles multi‐srcDir setups)
      File resRoot = sourceSets.main.resources.srcDirs.find { it.exists() } as File
      if (resRoot == null) {
        logger.lifecycle("No resources for ${project.path}, skipping assets.txt")
        return
      }

      File outFile = new File(resRoot, 'assets.txt')
      // Collect all regular files (skip directories) and sort for reproducibility
      def relPaths = fileTree(resRoot) {
        include '**/*.*'                       // take every file with an extension
      }.files.collect { f ->
        // Normalise to forward slashes so paths look the same on Windows & *nix
        resRoot.toPath().relativize(f.toPath())
          .toString()
          .replace('\\', '/')
      }.sort()

      outFile.text = relPaths.join('\n') + '\n'  // final \n → POSIX-friendly
      logger.lifecycle("Wrote ${relPaths.size()} entries to ${outFile}")
    }
  }

  // Ensure it runs early enough to be copied by processResources
  tasks.named('processResources').configure {
    dependsOn tasks.named('generateAssetsTxt')
  }
}
